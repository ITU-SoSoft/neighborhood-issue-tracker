============================= test session starts ==============================
platform linux -- Python 3.13.11, pytest-9.0.2, pluggy-1.6.0 -- /app/.venv/bin/python
cachedir: .pytest_cache
rootdir: /app
configfile: pyproject.toml
testpaths: tests
plugins: anyio-4.12.0, asyncio-1.3.0
asyncio: mode=Mode.AUTO, debug=False, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
collecting ... collected 653 items

tests/integration/analytics/test_analytics.py::TestDashboardAnalytics::test_manager_can_access_analytics PASSED [  0%]
tests/integration/analytics/test_analytics.py::TestDashboardAnalytics::test_support_can_access_analytics PASSED [  0%]
tests/integration/analytics/test_analytics.py::TestDashboardAnalytics::test_citizen_cannot_access_analytics PASSED [  0%]
tests/integration/analytics/test_analytics.py::TestDashboardAnalytics::test_date_range_filtering PASSED [  0%]
tests/integration/analytics/test_analytics.py::TestHeatmapAnalytics::test_heatmap_data PASSED [  0%]
tests/integration/analytics/test_analytics.py::TestHeatmapAnalytics::test_heatmap_with_category_filter PASSED [  0%]
tests/integration/analytics/test_analytics.py::TestHeatmapAnalytics::test_heatmap_with_status_filter PASSED [  1%]
tests/integration/analytics/test_analytics.py::TestHeatmapAnalytics::test_heatmap_with_tickets PASSED [  1%]
tests/integration/analytics/test_analytics.py::TestHeatmapAnalytics::test_citizen_cannot_access_heatmap PASSED [  1%]
tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_manager_can_access_team_performance FAILED [  1%]
tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_team_performance_with_team FAILED [  1%]
tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_team_performance_with_assigned_tickets FAILED [  1%]
tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_support_cannot_access_team_performance PASSED [  1%]
tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_citizen_cannot_access_team_performance PASSED [  2%]
tests/integration/analytics/test_analytics.py::TestTeamMemberPerformanceAnalytics::test_manager_can_access_member_performance PASSED [  2%]
tests/integration/analytics/test_analytics.py::TestTeamMemberPerformanceAnalytics::test_member_performance_includes_metrics PASSED [  2%]
tests/integration/analytics/test_analytics.py::TestTeamMemberPerformanceAnalytics::test_member_performance_nonexistent_team PASSED [  2%]
tests/integration/analytics/test_analytics.py::TestTeamMemberPerformanceAnalytics::test_support_cannot_access_member_performance PASSED [  2%]
tests/integration/analytics/test_analytics.py::TestCategoryAnalytics::test_manager_can_access_category_stats PASSED [  2%]
tests/integration/analytics/test_analytics.py::TestCategoryAnalytics::test_category_stats_with_category PASSED [  3%]
tests/integration/analytics/test_analytics.py::TestCategoryAnalytics::test_category_stats_with_days_param PASSED [  3%]
tests/integration/analytics/test_analytics.py::TestCategoryAnalytics::test_support_cannot_access_category_stats PASSED [  3%]
tests/integration/analytics/test_analytics.py::TestCategoryAnalytics::test_citizen_cannot_access_category_stats PASSED [  3%]
tests/integration/analytics/test_analytics.py::TestNeighborhoodAnalytics::test_manager_can_access_neighborhood_stats PASSED [  3%]
tests/integration/analytics/test_analytics.py::TestNeighborhoodAnalytics::test_neighborhood_stats_with_ticket PASSED [  3%]
tests/integration/analytics/test_analytics.py::TestNeighborhoodAnalytics::test_neighborhood_stats_limit_param PASSED [  3%]
tests/integration/analytics/test_analytics.py::TestNeighborhoodAnalytics::test_support_cannot_access_neighborhood_stats PASSED [  4%]
tests/integration/analytics/test_analytics.py::TestFeedbackTrendsAnalytics::test_manager_can_access_feedback_trends PASSED [  4%]
tests/integration/analytics/test_analytics.py::TestFeedbackTrendsAnalytics::test_feedback_trends_with_feedback PASSED [  4%]
tests/integration/analytics/test_analytics.py::TestFeedbackTrendsAnalytics::test_feedback_trends_with_days_param PASSED [  4%]
tests/integration/analytics/test_analytics.py::TestFeedbackTrendsAnalytics::test_support_cannot_access_feedback_trends PASSED [  4%]
tests/integration/analytics/test_analytics.py::TestFeedbackTrendsAnalytics::test_citizen_cannot_access_feedback_trends PASSED [  4%]
tests/integration/services/test_notification_integration.py::TestCreateNotification::test_create_notification_basic PASSED [  5%]
tests/integration/services/test_notification_integration.py::TestCreateNotification::test_create_notification_with_ticket_reference PASSED [  5%]
tests/integration/services/test_notification_integration.py::TestNotifyTicketCreated::test_notify_ticket_created PASSED [  5%]
tests/integration/services/test_notification_integration.py::TestNotifyTicketFollowed::test_notify_reporter_when_someone_follows PASSED [  5%]
tests/integration/services/test_notification_integration.py::TestNotifyTicketFollowed::test_no_notification_when_reporter_follows_own_ticket PASSED [  5%]
tests/integration/services/test_notification_integration.py::TestNotifyTicketStatusChanged::test_notify_reporter_on_status_change PASSED [  5%]
tests/integration/services/test_notification_integration.py::TestNotifyTicketStatusChanged::test_no_notification_when_reporter_changes_own_ticket PASSED [  5%]
tests/integration/services/test_notification_integration.py::TestNotifyTicketStatusChanged::test_notify_all_followers_on_status_change PASSED [  6%]
tests/integration/services/test_notification_integration.py::TestNotifyTicketStatusChanged::test_notification_content_contains_status_labels PASSED [  6%]
tests/integration/services/test_sms_integration.py::TestSMSServiceIntegration::test_send_otp_when_disabled PASSED [  6%]
tests/integration/services/test_sms_integration.py::TestSMSServiceIntegration::test_send_ticket_status_update_when_disabled PASSED [  6%]
tests/integration/services/test_sms_integration.py::TestSMSServiceIntegration::test_send_ticket_status_update_resolved PASSED [  6%]
tests/integration/services/test_sms_integration.py::TestSMSServiceIntegration::test_send_ticket_status_update_closed PASSED [  6%]
tests/integration/services/test_sms_integration.py::TestSMSServiceIntegration::test_send_ticket_status_update_escalated PASSED [  7%]
tests/integration/services/test_sms_integration.py::TestSMSServiceIntegration::test_send_ticket_status_update_unknown_status PASSED [  7%]
tests/integration/services/test_sms_integration.py::TestSMSServiceIntegration::test_send_sms_when_disabled PASSED [  7%]
tests/integration/services/test_sms_integration.py::TestSMSServiceWithTwilioEnabled::test_send_sms_success_with_client PASSED [  7%]
tests/integration/services/test_sms_integration.py::TestSMSServiceWithTwilioEnabled::test_send_sms_failure_with_client PASSED [  7%]
tests/integration/services/test_sms_integration.py::TestSMSServiceWithTwilioEnabled::test_send_sms_returns_false_when_client_not_initialized PASSED [  7%]
tests/integration/services/test_storage_integration.py::TestStorageServiceInit::test_storage_service_singleton_exists PASSED [  7%]
tests/integration/services/test_storage_integration.py::TestStorageServiceInit::test_storage_service_initial_state PASSED [  8%]
tests/integration/services/test_storage_integration.py::TestStorageServiceGetClient::test_get_client_creates_minio_client PASSED [  8%]
tests/integration/services/test_storage_integration.py::TestStorageServiceGetClient::test_get_client_reuses_existing_client PASSED [  8%]
tests/integration/services/test_storage_integration.py::TestEnsureBucketExists::test_creates_bucket_if_not_exists PASSED [  8%]
tests/integration/services/test_storage_integration.py::TestEnsureBucketExists::test_skips_if_bucket_exists PASSED [  8%]
tests/integration/services/test_storage_integration.py::TestEnsureBucketExists::test_handles_s3_error_gracefully PASSED [  8%]
tests/integration/services/test_storage_integration.py::TestEnsureBucketExists::test_skips_if_already_initialized PASSED [  9%]
tests/integration/services/test_storage_integration.py::TestEnsureBucketExists::test_skips_if_client_is_none PASSED [  9%]
tests/integration/services/test_storage_integration.py::TestUploadFile::test_upload_file_success PASSED [  9%]
tests/integration/services/test_storage_integration.py::TestUploadFile::test_upload_file_with_no_extension PASSED [  9%]
tests/integration/services/test_storage_integration.py::TestUploadFile::test_upload_file_s3_error_returns_none PASSED [  9%]
tests/integration/services/test_storage_integration.py::TestGetPresignedUrl::test_get_presigned_url_success PASSED [  9%]
tests/integration/services/test_storage_integration.py::TestGetPresignedUrl::test_get_presigned_url_with_custom_expiry PASSED [  9%]
tests/integration/services/test_storage_integration.py::TestGetPresignedUrl::test_get_presigned_url_s3_error_returns_none PASSED [ 10%]
tests/integration/services/test_storage_integration.py::TestDeleteFile::test_delete_file_success PASSED [ 10%]
tests/integration/services/test_storage_integration.py::TestDeleteFile::test_delete_file_s3_error_returns_false PASSED [ 10%]
tests/integration/services/test_storage_integration.py::TestGetPublicUrl::test_get_public_url_http PASSED [ 10%]
tests/integration/services/test_storage_integration.py::TestGetPublicUrl::test_get_public_url_https PASSED [ 10%]
tests/integration/services/test_team_assignment_integration.py::TestFindMatchingTeam::test_priority_1_category_and_district_match PASSED [ 10%]
tests/integration/services/test_team_assignment_integration.py::TestFindMatchingTeam::test_priority_2_category_and_city_match PASSED [ 11%]
tests/integration/services/test_team_assignment_integration.py::TestFindMatchingTeam::test_priority_3_category_only_match PASSED [ 11%]
tests/integration/services/test_team_assignment_integration.py::TestFindMatchingTeam::test_no_match_returns_none PASSED [ 11%]
tests/integration/services/test_team_assignment_integration.py::TestFindMatchingTeam::test_match_without_district PASSED [ 11%]
tests/integration/services/test_team_assignment_integration.py::TestGetTeamWorkload::test_workload_counts_active_tickets PASSED [ 11%]
tests/integration/services/test_team_assignment_integration.py::TestGetTeamWorkload::test_workload_excludes_deleted_tickets PASSED [ 11%]
tests/integration/services/test_team_assignment_integration.py::TestGetTeamWorkload::test_workload_for_team_with_no_tickets PASSED [ 11%]
tests/integration/services/test_team_assignment_integration.py::TestGetTeamWorkload::test_workload_only_counts_team_tickets PASSED [ 12%]
tests/integration/services/test_ticket_service_integration.py::TestCreateTicket::test_create_ticket_with_gps_coordinates PASSED [ 12%]
tests/integration/services/test_ticket_service_integration.py::TestCreateTicket::test_create_ticket_with_district_id PASSED [ 12%]
tests/integration/services/test_ticket_service_integration.py::TestCreateTicket::test_create_ticket_auto_assigns_team PASSED [ 12%]
tests/integration/services/test_ticket_service_integration.py::TestCreateTicket::test_create_ticket_auto_follows_reporter PASSED [ 12%]
tests/integration/services/test_ticket_service_integration.py::TestCreateTicket::test_create_ticket_creates_initial_status_log PASSED [ 12%]
tests/integration/services/test_ticket_service_integration.py::TestCreateTicket::test_create_ticket_triggers_notification PASSED [ 13%]
tests/integration/services/test_ticket_service_integration.py::TestCreateTicket::test_create_ticket_invalid_category_fails PASSED [ 13%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateTicket::test_update_ticket_title_and_description PASSED [ 13%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateTicket::test_update_ticket_change_category PASSED [ 13%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateTicket::test_citizen_cannot_update_non_new_ticket PASSED [ 13%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateTicket::test_staff_can_update_in_progress_ticket PASSED [ 13%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_creates_status_log FAILED [ 13%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_to_resolved_sets_resolved_at FAILED [ 14%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_invalid_transition_fails FAILED [ 14%]
tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_notifies_reporter FAILED [ 14%]
tests/integration/services/test_ticket_service_integration.py::TestAssignTicket::test_assign_ticket_to_team PASSED [ 14%]
tests/integration/services/test_ticket_service_integration.py::TestAssignTicket::test_reassign_ticket_to_different_team PASSED [ 14%]
tests/integration/services/test_ticket_service_integration.py::TestAssignTicket::test_assign_ticket_nonexistent_team_fails PASSED [ 14%]
tests/integration/test_addresses.py::TestListAddresses::test_list_addresses_empty PASSED [ 15%]
tests/integration/test_addresses.py::TestListAddresses::test_list_addresses_with_addresses PASSED [ 15%]
tests/integration/test_addresses.py::TestListAddresses::test_list_addresses_unauthenticated PASSED [ 15%]
tests/integration/test_addresses.py::TestCreateAddress::test_create_address PASSED [ 15%]
tests/integration/test_addresses.py::TestCreateAddress::test_create_duplicate_name PASSED [ 15%]
tests/integration/test_addresses.py::TestCreateAddress::test_create_address_max_limit PASSED [ 15%]
tests/integration/test_addresses.py::TestGetAddress::test_get_address PASSED [ 15%]
tests/integration/test_addresses.py::TestGetAddress::test_get_address_not_found PASSED [ 16%]
tests/integration/test_addresses.py::TestGetAddress::test_get_other_users_address PASSED [ 16%]
tests/integration/test_addresses.py::TestUpdateAddress::test_update_address PASSED [ 16%]
tests/integration/test_addresses.py::TestUpdateAddress::test_update_address_not_found PASSED [ 16%]
tests/integration/test_addresses.py::TestUpdateAddress::test_update_address_duplicate_name PASSED [ 16%]
tests/integration/test_addresses.py::TestDeleteAddress::test_delete_address PASSED [ 16%]
tests/integration/test_addresses.py::TestDeleteAddress::test_delete_address_not_found PASSED [ 16%]
tests/integration/test_auth_flows.py::TestAuthenticationFlows::test_login_and_access_protected_endpoint PASSED [ 17%]
tests/integration/test_auth_flows.py::TestAuthenticationFlows::test_refresh_token_flow PASSED [ 17%]
tests/integration/test_auth_flows.py::TestAuthenticationFlows::test_expired_token_rejected PASSED [ 17%]
tests/integration/test_auth_flows.py::TestAuthenticationFlows::test_invalid_token_rejected PASSED [ 17%]
tests/integration/test_auth_flows.py::TestAuthenticationFlows::test_access_token_cannot_be_used_as_refresh PASSED [ 17%]
tests/integration/test_auth_flows.py::TestTokenSecurity::test_deleted_user_token_rejected PASSED [ 17%]
tests/integration/test_auth_flows.py::TestTokenSecurity::test_inactive_user_token_rejected PASSED [ 18%]
tests/integration/test_auth_flows.py::TestTokenSecurity::test_missing_authorization_header PASSED [ 18%]
tests/integration/test_auth_flows.py::TestTokenSecurity::test_malformed_authorization_header PASSED [ 18%]
tests/integration/test_comments.py::TestListComments::test_get_ticket_comments PASSED [ 18%]
tests/integration/test_comments.py::TestListComments::test_nonexistent_ticket_returns_404 PASSED [ 18%]
tests/integration/test_comments.py::TestListComments::test_unauthenticated_cannot_list_comments PASSED [ 18%]
tests/integration/test_comments.py::TestCreateComment::test_citizen_creates_comment PASSED [ 18%]
tests/integration/test_comments.py::TestCreateComment::test_support_creates_public_comment PASSED [ 19%]
tests/integration/test_comments.py::TestCreateComment::test_support_creates_internal_comment PASSED [ 19%]
tests/integration/test_comments.py::TestCreateComment::test_citizen_cannot_create_internal_comment PASSED [ 19%]
tests/integration/test_comments.py::TestCreateComment::test_comment_content_validation PASSED [ 19%]
tests/integration/test_comments.py::TestCreateComment::test_nonexistent_ticket_returns_404 PASSED [ 19%]
tests/integration/test_comments.py::TestInternalCommentsVisibility::test_citizen_cannot_see_internal_comments PASSED [ 19%]
tests/integration/test_comments.py::TestInternalCommentsVisibility::test_support_can_see_internal_comments PASSED [ 20%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_citizen_returns_true_for_citizen PASSED [ 20%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_citizen_returns_false_for_support PASSED [ 20%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_citizen_returns_false_for_manager PASSED [ 20%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_support_returns_true_for_support PASSED [ 20%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_support_returns_false_for_citizen PASSED [ 20%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_support_returns_false_for_manager PASSED [ 20%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_manager_returns_true_for_manager PASSED [ 21%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_manager_returns_false_for_citizen PASSED [ 21%]
tests/integration/test_core_permissions.py::TestRoleCheckFunctions::test_is_manager_returns_false_for_support PASSED [ 21%]
tests/integration/test_core_permissions.py::TestSupportOrManagerCheck::test_returns_true_for_support PASSED [ 21%]
tests/integration/test_core_permissions.py::TestSupportOrManagerCheck::test_returns_true_for_manager PASSED [ 21%]
tests/integration/test_core_permissions.py::TestSupportOrManagerCheck::test_returns_false_for_citizen PASSED [ 21%]
tests/integration/test_core_permissions.py::TestCanManageTickets::test_support_can_manage_tickets PASSED [ 22%]
tests/integration/test_core_permissions.py::TestCanManageTickets::test_manager_can_manage_tickets PASSED [ 22%]
tests/integration/test_core_permissions.py::TestCanManageTickets::test_citizen_cannot_manage_tickets PASSED [ 22%]
tests/integration/test_core_permissions.py::TestCanViewAnalytics::test_manager_can_view_analytics PASSED [ 22%]
tests/integration/test_core_permissions.py::TestCanViewAnalytics::test_support_cannot_view_analytics PASSED [ 22%]
tests/integration/test_core_permissions.py::TestCanViewAnalytics::test_citizen_cannot_view_analytics PASSED [ 22%]
tests/integration/test_core_permissions.py::TestCanApproveEscalations::test_manager_can_approve_escalations PASSED [ 22%]
tests/integration/test_core_permissions.py::TestCanApproveEscalations::test_support_cannot_approve_escalations PASSED [ 23%]
tests/integration/test_core_permissions.py::TestCanApproveEscalations::test_citizen_cannot_approve_escalations PASSED [ 23%]
tests/integration/test_core_permissions.py::TestRequireRolesDecorator::test_allows_user_with_correct_role PASSED [ 23%]
tests/integration/test_core_permissions.py::TestRequireRolesDecorator::test_rejects_user_with_wrong_role PASSED [ 23%]
tests/integration/test_core_permissions.py::TestRequireRolesDecorator::test_allows_multiple_roles PASSED [ 23%]
tests/integration/test_core_permissions.py::TestRequireRolesDecorator::test_rejects_when_user_not_in_allowed_roles PASSED [ 23%]
tests/integration/test_core_permissions.py::TestRequireRolesDecorator::test_rejects_when_no_user_provided PASSED [ 24%]
tests/integration/test_feedback.py::TestCreateFeedback::test_citizen_creates_feedback_on_resolved_ticket PASSED [ 24%]
tests/integration/test_feedback.py::TestCreateFeedback::test_rating_validation_min PASSED [ 24%]
tests/integration/test_feedback.py::TestCreateFeedback::test_rating_validation_max PASSED [ 24%]
tests/integration/test_feedback.py::TestCreateFeedback::test_feedback_without_comment PASSED [ 24%]
tests/integration/test_feedback.py::TestCreateFeedback::test_cannot_give_feedback_on_new_ticket PASSED [ 24%]
tests/integration/test_feedback.py::TestCreateFeedback::test_only_reporter_can_give_feedback PASSED [ 24%]
tests/integration/test_feedback.py::TestCreateFeedback::test_nonexistent_ticket_returns_404 PASSED [ 25%]
tests/integration/test_feedback.py::TestGetFeedback::test_get_ticket_feedback PASSED [ 25%]
tests/integration/test_feedback.py::TestGetFeedback::test_no_feedback_returns_404 PASSED [ 25%]
tests/integration/test_notifications.py::TestListNotifications::test_user_lists_own_notifications PASSED [ 25%]
tests/integration/test_notifications.py::TestListNotifications::test_unauthenticated_cannot_list_notifications PASSED [ 25%]
tests/integration/test_notifications.py::TestUnreadCount::test_get_unread_count PASSED [ 25%]
tests/integration/test_notifications.py::TestMarkAsRead::test_mark_notification_as_read PASSED [ 26%]
tests/integration/test_notifications.py::TestMarkAsRead::test_cannot_mark_others_notification PASSED [ 26%]
tests/integration/test_notifications.py::TestMarkAsRead::test_nonexistent_notification_returns_404 PASSED [ 26%]
tests/integration/test_notifications.py::TestMarkAllAsRead::test_mark_all_notifications_as_read PASSED [ 26%]
tests/integration/test_notifications.py::TestMarkAllAsRead::test_mark_all_read_with_no_notifications PASSED [ 26%]
tests/integration/test_notifications.py::TestMarkAllAsRead::test_mark_all_read_requires_auth PASSED [ 26%]
tests/integration/test_permissions_integration.py::TestRoleBasedAccess::test_citizen_cannot_access_analytics PASSED [ 26%]
tests/integration/test_permissions_integration.py::TestRoleBasedAccess::test_support_can_access_analytics PASSED [ 27%]
tests/integration/test_permissions_integration.py::TestRoleBasedAccess::test_manager_can_access_analytics PASSED [ 27%]
tests/integration/test_permissions_integration.py::TestEscalationPermissions::test_only_manager_can_approve_escalation PASSED [ 27%]
tests/integration/test_permissions_integration.py::TestEscalationPermissions::test_only_manager_can_reject_escalation PASSED [ 27%]
tests/integration/test_permissions_integration.py::TestTicketManagementPermissions::test_support_can_manage_team_tickets PASSED [ 27%]
tests/integration/test_permissions_integration.py::TestTicketManagementPermissions::test_support_can_manage_any_ticket FAILED [ 27%]
tests/integration/test_permissions_integration.py::TestTicketManagementPermissions::test_manager_can_manage_any_ticket PASSED [ 28%]
tests/integration/test_permissions_integration.py::TestUserManagementPermissions::test_only_manager_can_delete_users PASSED [ 28%]
tests/integration/test_permissions_integration.py::TestUserManagementPermissions::test_only_manager_can_change_user_roles PASSED [ 28%]
tests/integration/test_teams.py::TestListTeams::test_support_lists_teams PASSED [ 28%]
tests/integration/test_teams.py::TestListTeams::test_manager_lists_teams FAILED [ 28%]
tests/integration/test_teams.py::TestListTeams::test_citizen_cannot_list_teams PASSED [ 28%]
tests/integration/test_teams.py::TestGetTeam::test_support_gets_team PASSED [ 28%]
tests/integration/test_teams.py::TestGetTeam::test_manager_gets_team PASSED [ 29%]
tests/integration/test_teams.py::TestGetTeam::test_nonexistent_team_returns_404 PASSED [ 29%]
tests/integration/test_teams.py::TestCreateTeam::test_manager_creates_team PASSED [ 29%]
tests/integration/test_teams.py::TestCreateTeam::test_support_cannot_create_team PASSED [ 29%]
tests/integration/test_teams.py::TestCreateTeam::test_citizen_cannot_create_team PASSED [ 29%]
tests/integration/test_teams.py::TestCreateTeam::test_team_name_required PASSED [ 29%]
tests/integration/test_teams.py::TestUpdateTeam::test_manager_updates_team PASSED [ 30%]
tests/integration/test_teams.py::TestUpdateTeam::test_support_cannot_update_team PASSED [ 30%]
tests/integration/test_teams.py::TestDeleteTeam::test_manager_deletes_team PASSED [ 30%]
tests/integration/test_teams.py::TestDeleteTeam::test_support_cannot_delete_team PASSED [ 30%]
tests/integration/test_teams.py::TestTeamMembers::test_manager_adds_member_to_team PASSED [ 30%]
tests/integration/test_teams.py::TestTeamMembers::test_support_cannot_add_members PASSED [ 30%]
tests/integration/test_teams.py::TestTeamMembers::test_add_nonexistent_user_fails PASSED [ 30%]
tests/integration/test_teams.py::TestTeamMembers::test_manager_removes_member_from_team PASSED [ 31%]
tests/integration/tickets/test_followers.py::TestFollowTicket::test_citizen_follows_ticket PASSED [ 31%]
tests/integration/tickets/test_followers.py::TestFollowTicket::test_follow_ticket_twice_returns_already_following PASSED [ 31%]
tests/integration/tickets/test_followers.py::TestFollowTicket::test_follow_nonexistent_ticket_returns_404 PASSED [ 31%]
tests/integration/tickets/test_followers.py::TestFollowTicket::test_unauthenticated_cannot_follow PASSED [ 31%]
tests/integration/tickets/test_followers.py::TestUnfollowTicket::test_citizen_unfollows_ticket PASSED [ 31%]
tests/integration/tickets/test_followers.py::TestUnfollowTicket::test_unfollow_ticket_not_following PASSED [ 32%]
tests/integration/tickets/test_followers.py::TestUnfollowTicket::test_unauthenticated_cannot_unfollow PASSED [ 32%]
tests/integration/tickets/test_photos.py::TestUploadReportPhoto::test_reporter_can_upload_report_photo PASSED [ 32%]
tests/integration/tickets/test_photos.py::TestUploadReportPhoto::test_reporter_upload_defaults_to_report_type PASSED [ 32%]
tests/integration/tickets/test_photos.py::TestUploadReportPhoto::test_non_reporter_cannot_upload_report_photo PASSED [ 32%]
tests/integration/tickets/test_photos.py::TestUploadProofPhoto::test_support_can_upload_proof_photo PASSED [ 32%]
tests/integration/tickets/test_photos.py::TestUploadProofPhoto::test_manager_can_upload_proof_photo PASSED [ 32%]
tests/integration/tickets/test_photos.py::TestUploadProofPhoto::test_citizen_cannot_upload_proof_photo PASSED [ 33%]
tests/integration/tickets/test_photos.py::TestPhotoUploadErrors::test_upload_to_nonexistent_ticket_returns_404 PASSED [ 33%]
tests/integration/tickets/test_photos.py::TestPhotoUploadErrors::test_unauthenticated_upload_returns_401 PASSED [ 33%]
tests/integration/tickets/test_photos.py::TestPhotoUploadErrors::test_storage_failure_returns_error PASSED [ 33%]
tests/integration/tickets/test_search.py::TestNearbyTickets::test_search_nearby_tickets PASSED [ 33%]
tests/integration/tickets/test_search.py::TestNearbyTickets::test_search_nearby_with_category_filter PASSED [ 33%]
tests/integration/tickets/test_search.py::TestNearbyTickets::test_search_nearby_no_results PASSED [ 33%]
tests/integration/tickets/test_search.py::TestNearbyTickets::test_search_nearby_invalid_latitude PASSED [ 34%]
tests/integration/tickets/test_search.py::TestNearbyTickets::test_search_nearby_invalid_longitude PASSED [ 34%]
tests/integration/tickets/test_search.py::TestNearbyTickets::test_search_nearby_radius_limits PASSED [ 34%]
tests/integration/tickets/test_search.py::TestNearbyTickets::test_unauthenticated_cannot_search_nearby PASSED [ 34%]
tests/integration/tickets/test_search.py::TestNearbyTicketsAdditional::test_nearby_tickets_only_active_statuses PASSED [ 34%]
tests/integration/tickets/test_search.py::TestNearbyTicketsAdditional::test_nearby_tickets_limit_10_results PASSED [ 34%]
tests/integration/tickets/test_search.py::TestNearbyTicketsAdditional::test_nearby_tickets_includes_follower_count PASSED [ 35%]
tests/integration/tickets/test_search.py::TestNearbyTicketsAdditional::test_nearby_tickets_includes_category_name PASSED [ 35%]
tests/integration/tickets/test_search.py::TestNearbyTicketsAdditional::test_nearby_tickets_excludes_deleted PASSED [ 35%]
tests/integration/tickets/test_ticket_assignments.py::TestMyTickets::test_citizen_gets_own_tickets PASSED [ 35%]
tests/integration/tickets/test_ticket_assignments.py::TestMyTickets::test_citizen_with_no_tickets PASSED [ 35%]
tests/integration/tickets/test_ticket_assignments.py::TestMyTickets::test_unauthenticated_cannot_get_my_tickets PASSED [ 35%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignedTickets::test_support_gets_team_assigned_tickets PASSED [ 35%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignedTickets::test_support_without_team_gets_empty PASSED [ 36%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignedTickets::test_citizen_cannot_access_assigned_tickets PASSED [ 36%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignedTickets::test_manager_gets_all_assigned_tickets PASSED [ 36%]
tests/integration/tickets/test_ticket_assignments.py::TestFollowedTickets::test_user_gets_followed_tickets PASSED [ 36%]
tests/integration/tickets/test_ticket_assignments.py::TestFollowedTickets::test_unauthenticated_cannot_access_followed PASSED [ 36%]
tests/integration/tickets/test_ticket_assignments.py::TestFollowedTickets::test_followed_tickets_with_pagination PASSED [ 36%]
tests/integration/tickets/test_ticket_assignments.py::TestFollowedTickets::test_user_with_followed_tickets_sees_others_tickets PASSED [ 37%]
tests/integration/tickets/test_ticket_assignments.py::TestAllTickets::test_manager_gets_all_tickets PASSED [ 37%]
tests/integration/tickets/test_ticket_assignments.py::TestAllTickets::test_support_can_access_all_tickets PASSED [ 37%]
tests/integration/tickets/test_ticket_assignments.py::TestAllTickets::test_citizen_cannot_access_all_tickets PASSED [ 37%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignTicket::test_manager_assigns_ticket_to_team PASSED [ 37%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignTicket::test_support_cannot_assign_ticket PASSED [ 37%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignTicket::test_citizen_cannot_assign_ticket PASSED [ 37%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignTicket::test_assign_to_nonexistent_team_fails PASSED [ 38%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignTicket::test_assign_nonexistent_ticket_fails PASSED [ 38%]
tests/integration/tickets/test_ticket_assignments.py::TestAssignTicket::test_reassign_ticket_to_different_team PASSED [ 38%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_citizen_creates_ticket_successfully PASSED [ 38%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_create_ticket_with_gps_coordinates PASSED [ 38%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_create_ticket_inactive_category_fails PASSED [ 38%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_create_ticket_nonexistent_category_fails PASSED [ 39%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_create_ticket_title_validation PASSED [ 39%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_create_ticket_description_validation PASSED [ 39%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_create_ticket_location_required PASSED [ 39%]
tests/integration/tickets/test_ticket_crud.py::TestCreateTicket::test_unauthenticated_cannot_create_ticket PASSED [ 39%]
tests/integration/tickets/test_ticket_crud.py::TestListTickets::test_support_lists_all_tickets PASSED [ 39%]
tests/integration/tickets/test_ticket_crud.py::TestListTickets::test_manager_lists_all_tickets PASSED [ 39%]
tests/integration/tickets/test_ticket_crud.py::TestListTickets::test_citizen_cannot_list_all_tickets PASSED [ 40%]
tests/integration/tickets/test_ticket_crud.py::TestListTickets::test_filter_by_status PASSED [ 40%]
tests/integration/tickets/test_ticket_crud.py::TestListTickets::test_filter_by_category PASSED [ 40%]
tests/integration/tickets/test_ticket_crud.py::TestListTickets::test_pagination PASSED [ 40%]
tests/integration/tickets/test_ticket_crud.py::TestGetTicket::test_citizen_gets_own_ticket PASSED [ 40%]
tests/integration/tickets/test_ticket_crud.py::TestGetTicket::test_citizen_gets_other_ticket PASSED [ 40%]
tests/integration/tickets/test_ticket_crud.py::TestGetTicket::test_support_gets_any_ticket PASSED [ 41%]
tests/integration/tickets/test_ticket_crud.py::TestGetTicket::test_nonexistent_ticket_returns_404 PASSED [ 41%]
tests/integration/tickets/test_ticket_crud.py::TestUpdateTicket::test_citizen_updates_own_new_ticket PASSED [ 41%]
tests/integration/tickets/test_ticket_crud.py::TestUpdateTicket::test_citizen_cannot_update_in_progress_ticket PASSED [ 41%]
tests/integration/tickets/test_ticket_crud.py::TestUpdateTicket::test_support_updates_any_ticket PASSED [ 41%]
tests/integration/tickets/test_ticket_crud.py::TestUpdateTicket::test_cannot_update_closed_ticket PASSED [ 41%]
tests/integration/tickets/test_ticket_crud.py::TestUpdateTicket::test_update_with_invalid_category_fails PASSED [ 41%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_citizen_deletes_own_new_ticket PASSED [ 42%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_citizen_cannot_delete_in_progress_ticket PASSED [ 42%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_citizen_cannot_delete_others_ticket PASSED [ 42%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_unauthenticated_cannot_delete_ticket PASSED [ 42%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_delete_nonexistent_ticket_returns_404 PASSED [ 42%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_support_cannot_delete_others_ticket PASSED [ 42%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_manager_cannot_delete_others_ticket PASSED [ 43%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_support_deletes_own_new_ticket PASSED [ 43%]
tests/integration/tickets/test_ticket_crud.py::TestDeleteTicket::test_manager_deletes_own_new_ticket PASSED [ 43%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_to_in_progress FAILED [ 43%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_in_progress_to_resolved FAILED [ 43%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_resolved_to_closed FAILED [ 43%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_resolved_to_in_progress_reopen FAILED [ 43%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_to_escalated FAILED [ 44%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_in_progress_to_escalated FAILED [ 44%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_escalated_to_in_progress FAILED [ 44%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_cannot_jump_to_resolved FAILED [ 44%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_cannot_jump_to_closed FAILED [ 44%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_closed_cannot_change FAILED [ 44%]
tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_in_progress_cannot_jump_to_closed FAILED [ 45%]
tests/integration/tickets/test_ticket_status.py::TestStatusPermissions::test_citizen_cannot_change_status PASSED [ 45%]
tests/integration/tickets/test_ticket_status.py::TestStatusPermissions::test_support_can_change_status FAILED [ 45%]
tests/integration/tickets/test_ticket_status.py::TestStatusPermissions::test_manager_can_change_status PASSED [ 45%]
tests/integration/tickets/test_ticket_status.py::TestStatusPermissions::test_unauthenticated_cannot_change_status PASSED [ 45%]
tests/integration/tickets/test_ticket_status.py::TestStatusSideEffects::test_resolved_sets_resolved_at FAILED [ 45%]
tests/integration/tickets/test_ticket_status.py::TestStatusSideEffects::test_status_change_with_comment FAILED [ 45%]
tests/integration/tickets/test_ticket_status.py::TestStatusSideEffects::test_nonexistent_ticket_returns_404 PASSED [ 46%]
tests/test_auth.py::TestRequestOTP::test_request_otp_valid_phone PASSED  [ 46%]
tests/test_auth.py::TestRequestOTP::test_request_otp_invalid_phone PASSED [ 46%]
tests/test_auth.py::TestRequestOTP::test_request_otp_non_turkish_phone PASSED [ 46%]
tests/test_auth.py::TestVerifyOTP::test_verify_otp_invalid_code PASSED   [ 46%]
tests/test_auth.py::TestLogin::test_login_verified_user PASSED           [ 46%]
tests/test_auth.py::TestLogin::test_login_unverified_user PASSED         [ 47%]
tests/test_auth.py::TestLogin::test_login_nonexistent_user PASSED        [ 47%]
tests/test_auth.py::TestGetCurrentUser::test_get_me_authenticated PASSED [ 47%]
tests/test_auth.py::TestGetCurrentUser::test_get_me_unauthenticated PASSED [ 47%]
tests/test_auth.py::TestGetCurrentUser::test_get_me_invalid_token PASSED [ 47%]
tests/test_auth.py::TestRefreshToken::test_refresh_token_missing PASSED  [ 47%]
tests/test_auth.py::TestRefreshToken::test_refresh_token_valid PASSED    [ 47%]
tests/test_auth.py::TestRefreshToken::test_refresh_token_invalid PASSED  [ 48%]
tests/test_auth.py::TestRefreshToken::test_refresh_token_wrong_type PASSED [ 48%]
tests/test_auth.py::TestRegister::test_register_new_user PASSED          [ 48%]
tests/test_auth.py::TestRegister::test_register_duplicate_email PASSED   [ 48%]
tests/test_auth.py::TestRegister::test_register_duplicate_phone PASSED   [ 48%]
tests/test_auth.py::TestStaffLogin::test_staff_login_support PASSED      [ 48%]
tests/test_auth.py::TestStaffLogin::test_staff_login_manager PASSED      [ 49%]
tests/test_auth.py::TestStaffLogin::test_staff_login_citizen_rejected PASSED [ 49%]
tests/test_auth.py::TestStaffLogin::test_staff_login_wrong_password PASSED [ 49%]
tests/test_auth.py::TestStaffLogin::test_staff_login_unverified_rejected PASSED [ 49%]
tests/test_auth.py::TestOTPVerification::test_verify_valid_otp_existing_user PASSED [ 49%]
tests/test_auth.py::TestOTPVerification::test_verify_expired_otp PASSED  [ 49%]
tests/test_auth.py::TestOTPVerification::test_request_otp_existing_verified_user PASSED [ 49%]
tests/test_auth.py::TestLoginWrongPassword::test_login_wrong_password PASSED [ 50%]
tests/test_categories.py::TestListCategories::test_list_categories_unauthenticated PASSED [ 50%]
tests/test_categories.py::TestListCategories::test_list_categories_authenticated PASSED [ 50%]
tests/test_categories.py::TestGetCategory::test_get_category PASSED      [ 50%]
tests/test_categories.py::TestGetCategory::test_get_nonexistent_category PASSED [ 50%]
tests/test_categories.py::TestCreateCategory::test_create_category_as_manager PASSED [ 50%]
tests/test_categories.py::TestCreateCategory::test_create_category_as_support PASSED [ 50%]
tests/test_categories.py::TestCreateCategory::test_create_category_as_citizen PASSED [ 51%]
tests/test_categories.py::TestCreateCategory::test_create_duplicate_category PASSED [ 51%]
tests/test_categories.py::TestUpdateCategory::test_update_category_as_manager PASSED [ 51%]
tests/test_categories.py::TestUpdateCategory::test_update_category_as_citizen PASSED [ 51%]
tests/test_categories.py::TestUpdateCategory::test_update_nonexistent_category PASSED [ 51%]
tests/test_categories.py::TestUpdateCategory::test_deactivate_category PASSED [ 51%]
tests/test_escalations.py::test_support_creates_escalation_for_own_team_ticket FAILED [ 52%]
tests/test_escalations.py::test_support_cannot_escalate_another_teams_ticket PASSED [ 52%]
tests/test_escalations.py::test_support_cannot_escalate_unassigned_ticket PASSED [ 52%]
tests/test_escalations.py::test_citizen_cannot_create_escalation PASSED  [ 52%]
tests/test_escalations.py::test_escalation_ticket_not_found PASSED       [ 52%]
tests/test_escalations.py::test_cannot_escalate_with_pending_escalation PASSED [ 52%]
tests/test_escalations.py::test_can_reescalate_after_rejection FAILED    [ 52%]
tests/test_escalations.py::test_cannot_reescalate_after_approval PASSED  [ 53%]
tests/test_escalations.py::test_manager_sees_all_escalations PASSED      [ 53%]
tests/test_escalations.py::test_support_sees_only_own_team_escalations PASSED [ 53%]
tests/test_escalations.py::test_support_other_team_sees_no_escalations PASSED [ 53%]
tests/test_escalations.py::test_citizen_cannot_list_escalations PASSED   [ 53%]
tests/test_escalations.py::test_support_can_view_escalation PASSED       [ 53%]
tests/test_escalations.py::test_escalation_not_found PASSED              [ 54%]
tests/test_escalations.py::test_manager_approves_escalation PASSED       [ 54%]
tests/test_escalations.py::test_support_cannot_approve_escalation PASSED [ 54%]
tests/test_escalations.py::test_manager_rejects_escalation PASSED        [ 54%]
tests/test_escalations.py::test_support_cannot_reject_escalation PASSED  [ 54%]
tests/test_users.py::TestListUsers::test_list_users_as_manager PASSED    [ 54%]
tests/test_users.py::TestListUsers::test_list_users_as_support PASSED    [ 54%]
tests/test_users.py::TestListUsers::test_list_users_as_citizen PASSED    [ 55%]
tests/test_users.py::TestListUsers::test_list_users_unauthenticated PASSED [ 55%]
tests/test_users.py::TestGetUser::test_get_own_user PASSED               [ 55%]
tests/test_users.py::TestGetUser::test_get_other_user_as_citizen PASSED  [ 55%]
tests/test_users.py::TestGetUser::test_get_other_user_as_manager PASSED  [ 55%]
tests/test_users.py::TestUpdateUser::test_update_own_profile PASSED      [ 55%]
tests/test_users.py::TestUpdateUser::test_update_other_user_profile PASSED [ 56%]
tests/test_users.py::TestUpdateUserRole::test_update_role_as_manager PASSED [ 56%]
tests/test_users.py::TestUpdateUserRole::test_update_role_as_support PASSED [ 56%]
tests/test_users.py::TestUpdateUserRole::test_update_role_invalid_role PASSED [ 56%]
tests/test_users.py::TestDeleteUser::test_delete_user_as_manager PASSED  [ 56%]
tests/test_users.py::TestDeleteUser::test_delete_user_as_citizen PASSED  [ 56%]
tests/test_users.py::TestListUsersFiltering::test_list_users_filter_by_role PASSED [ 56%]
tests/test_users.py::TestListUsersFiltering::test_list_users_filter_by_team_id PASSED [ 57%]
tests/test_users.py::TestListUsersFiltering::test_list_users_pagination PASSED [ 57%]
tests/test_users.py::TestUpdateUserAdditional::test_update_user_duplicate_phone_fails PASSED [ 57%]
tests/test_users.py::TestUpdateUserAdditional::test_update_user_partial_update PASSED [ 57%]
tests/test_users.py::TestUpdateUserRoleAdditional::test_update_role_with_team_assignment PASSED [ 57%]
tests/test_users.py::TestUpdateUserRoleAdditional::test_update_role_nonexistent_user PASSED [ 57%]
tests/test_users.py::TestDeleteUserAdditional::test_delete_user_soft_delete_verification PASSED [ 58%]
tests/test_users.py::TestDeleteUserAdditional::test_delete_nonexistent_user PASSED [ 58%]
tests/test_users.py::TestDeleteUserAdditional::test_get_deleted_user_returns_404 PASSED [ 58%]
tests/unit/api/test_addresses.py::TestGetSavedAddresses::test_get_saved_addresses_success PASSED [ 58%]
tests/unit/api/test_addresses.py::TestGetSavedAddresses::test_get_saved_addresses_empty PASSED [ 58%]
tests/unit/api/test_addresses.py::TestCreateSavedAddress::test_create_saved_address_success PASSED [ 58%]
tests/unit/api/test_addresses.py::TestCreateSavedAddress::test_create_saved_address_duplicate_name PASSED [ 58%]
tests/unit/api/test_addresses.py::TestCreateSavedAddress::test_create_saved_address_max_limit PASSED [ 59%]
tests/unit/api/test_addresses.py::TestGetSavedAddress::test_get_saved_address_success PASSED [ 59%]
tests/unit/api/test_addresses.py::TestGetSavedAddress::test_get_saved_address_not_found PASSED [ 59%]
tests/unit/api/test_addresses.py::TestUpdateSavedAddress::test_update_saved_address_success PASSED [ 59%]
tests/unit/api/test_addresses.py::TestUpdateSavedAddress::test_update_saved_address_not_found PASSED [ 59%]
tests/unit/api/test_addresses.py::TestDeleteSavedAddress::test_delete_saved_address_success PASSED [ 59%]
tests/unit/api/test_addresses.py::TestDeleteSavedAddress::test_delete_saved_address_not_found PASSED [ 60%]
tests/unit/api/test_analytics.py::TestGetDashboardKPIs::test_dashboard_kpis_with_data PASSED [ 60%]
tests/unit/api/test_analytics.py::TestGetDashboardKPIs::test_dashboard_kpis_empty_data PASSED [ 60%]
tests/unit/api/test_analytics.py::TestGetTicketHeatmap::test_heatmap_with_data PASSED [ 60%]
tests/unit/api/test_analytics.py::TestGetTicketHeatmap::test_heatmap_empty PASSED [ 60%]
tests/unit/api/test_analytics.py::TestGetTicketHeatmap::test_heatmap_with_category_filter PASSED [ 60%]
tests/unit/api/test_analytics.py::TestGetTeamPerformance::test_team_performance_with_teams FAILED [ 60%]
tests/unit/api/test_analytics.py::TestGetTeamPerformance::test_team_performance_empty_team FAILED [ 61%]
tests/unit/api/test_analytics.py::TestGetTeamMemberPerformance::test_member_performance_success PASSED [ 61%]
tests/unit/api/test_analytics.py::TestGetTeamMemberPerformance::test_member_performance_team_not_found PASSED [ 61%]
tests/unit/api/test_analytics.py::TestGetCategoryStatistics::test_category_stats_success PASSED [ 61%]
tests/unit/api/test_analytics.py::TestGetNeighborhoodStatistics::test_neighborhood_stats_success PASSED [ 61%]
tests/unit/api/test_analytics.py::TestGetNeighborhoodStatistics::test_neighborhood_stats_empty PASSED [ 61%]
tests/unit/api/test_analytics.py::TestGetFeedbackTrends::test_feedback_trends_with_data PASSED [ 62%]
tests/unit/api/test_analytics.py::TestGetFeedbackTrends::test_feedback_trends_no_feedback PASSED [ 62%]
tests/unit/api/test_auth.py::TestRequestOTP::test_request_otp_for_new_phone PASSED [ 62%]
tests/unit/api/test_auth.py::TestRequestOTP::test_request_otp_for_existing_verified_user PASSED [ 62%]
tests/unit/api/test_auth.py::TestVerifyOTP::test_verify_valid_otp_new_user PASSED [ 62%]
tests/unit/api/test_auth.py::TestVerifyOTP::test_verify_otp_invalid_code PASSED [ 62%]
tests/unit/api/test_auth.py::TestVerifyOTP::test_verify_otp_expired PASSED [ 62%]
tests/unit/api/test_auth.py::TestRegister::test_register_success PASSED  [ 63%]
tests/unit/api/test_auth.py::TestRegister::test_register_phone_already_exists PASSED [ 63%]
tests/unit/api/test_auth.py::TestRegister::test_register_email_already_exists PASSED [ 63%]
tests/unit/api/test_auth.py::TestLogin::test_login_success PASSED        [ 63%]
tests/unit/api/test_auth.py::TestLogin::test_login_invalid_credentials PASSED [ 63%]
tests/unit/api/test_auth.py::TestLogin::test_login_wrong_password PASSED [ 63%]
tests/unit/api/test_auth.py::TestLogin::test_login_unverified_user PASSED [ 64%]
tests/unit/api/test_auth.py::TestStaffLogin::test_staff_login_success PASSED [ 64%]
tests/unit/api/test_auth.py::TestStaffLogin::test_staff_login_citizen_rejected PASSED [ 64%]
tests/unit/api/test_auth.py::TestStaffLogin::test_staff_login_unverified PASSED [ 64%]
tests/unit/api/test_auth.py::TestRefreshToken::test_refresh_token_success PASSED [ 64%]
tests/unit/api/test_auth.py::TestRefreshToken::test_refresh_token_invalid PASSED [ 64%]
tests/unit/api/test_auth.py::TestRefreshToken::test_refresh_token_wrong_type PASSED [ 64%]
tests/unit/api/test_auth.py::TestGetCurrentUserInfo::test_returns_user_info FAILED [ 65%]
tests/unit/api/test_categories.py::TestListCategories::test_list_categories_active_only PASSED [ 65%]
tests/unit/api/test_categories.py::TestListCategories::test_list_categories_include_inactive PASSED [ 65%]
tests/unit/api/test_categories.py::TestGetCategory::test_get_category_success PASSED [ 65%]
tests/unit/api/test_categories.py::TestGetCategory::test_get_category_not_found PASSED [ 65%]
tests/unit/api/test_categories.py::TestCreateCategory::test_create_category_success PASSED [ 65%]
tests/unit/api/test_categories.py::TestCreateCategory::test_create_category_duplicate_name PASSED [ 66%]
tests/unit/api/test_categories.py::TestUpdateCategory::test_update_category_success PASSED [ 66%]
tests/unit/api/test_categories.py::TestUpdateCategory::test_update_category_not_found PASSED [ 66%]
tests/unit/api/test_categories.py::TestUpdateCategory::test_update_category_duplicate_name PASSED [ 66%]
tests/unit/api/test_categories.py::TestUpdateCategory::test_update_category_deactivate PASSED [ 66%]
tests/unit/api/test_comments.py::TestListComments::test_list_comments_citizen_only_public PASSED [ 66%]
tests/unit/api/test_comments.py::TestListComments::test_list_comments_support_sees_all PASSED [ 66%]
tests/unit/api/test_comments.py::TestListComments::test_list_comments_ticket_not_found PASSED [ 67%]
tests/unit/api/test_comments.py::TestCreateComment::test_create_public_comment_success PASSED [ 67%]
tests/unit/api/test_comments.py::TestCreateComment::test_create_internal_comment_by_support PASSED [ 67%]
tests/unit/api/test_comments.py::TestCreateComment::test_citizen_cannot_create_internal_comment PASSED [ 67%]
tests/unit/api/test_comments.py::TestCreateComment::test_create_comment_ticket_not_found PASSED [ 67%]
tests/unit/api/test_deps.py::TestGetCurrentUser::test_returns_user_with_valid_token PASSED [ 67%]
tests/unit/api/test_deps.py::TestGetCurrentUser::test_raises_unauthorized_when_token_invalid PASSED [ 67%]
tests/unit/api/test_deps.py::TestGetCurrentUser::test_raises_unauthorized_when_wrong_token_type PASSED [ 68%]
tests/unit/api/test_deps.py::TestGetCurrentUser::test_raises_unauthorized_when_no_subject PASSED [ 68%]
tests/unit/api/test_deps.py::TestGetCurrentUser::test_raises_unauthorized_when_user_not_found PASSED [ 68%]
tests/unit/api/test_deps.py::TestGetCurrentUser::test_raises_unauthorized_when_user_inactive PASSED [ 68%]
tests/unit/api/test_deps.py::TestGetCurrentActiveUser::test_returns_active_user PASSED [ 68%]
tests/unit/api/test_deps.py::TestGetCurrentActiveUser::test_raises_forbidden_when_inactive PASSED [ 68%]
tests/unit/api/test_deps.py::TestGetCurrentVerifiedUser::test_returns_verified_user PASSED [ 69%]
tests/unit/api/test_deps.py::TestGetCurrentVerifiedUser::test_raises_forbidden_when_not_verified PASSED [ 69%]
tests/unit/api/test_deps.py::TestGetSupportUser::test_returns_support_user PASSED [ 69%]
tests/unit/api/test_deps.py::TestGetSupportUser::test_returns_manager_user PASSED [ 69%]
tests/unit/api/test_deps.py::TestGetSupportUser::test_raises_forbidden_for_citizen PASSED [ 69%]
tests/unit/api/test_deps.py::TestGetManagerUser::test_returns_manager_user PASSED [ 69%]
tests/unit/api/test_deps.py::TestGetManagerUser::test_raises_forbidden_for_support PASSED [ 69%]
tests/unit/api/test_deps.py::TestGetManagerUser::test_raises_forbidden_for_citizen PASSED [ 70%]
tests/unit/api/test_escalations.py::TestCreateEscalation::test_create_escalation_success FAILED [ 70%]
tests/unit/api/test_escalations.py::TestCreateEscalation::test_create_escalation_ticket_not_found PASSED [ 70%]
tests/unit/api/test_escalations.py::TestCreateEscalation::test_create_escalation_not_assigned_to_team PASSED [ 70%]
tests/unit/api/test_escalations.py::TestCreateEscalation::test_create_escalation_different_team PASSED [ 70%]
tests/unit/api/test_escalations.py::TestCreateEscalation::test_create_escalation_pending_exists FAILED [ 70%]
tests/unit/api/test_escalations.py::TestListEscalations::test_list_escalations_as_manager FAILED [ 71%]
tests/unit/api/test_escalations.py::TestListEscalations::test_list_escalations_filter_by_status PASSED [ 71%]
tests/unit/api/test_escalations.py::TestGetEscalation::test_get_escalation_success FAILED [ 71%]
tests/unit/api/test_escalations.py::TestGetEscalation::test_get_escalation_not_found PASSED [ 71%]
tests/unit/api/test_escalations.py::TestApproveEscalation::test_approve_escalation_success FAILED [ 71%]
tests/unit/api/test_escalations.py::TestApproveEscalation::test_approve_escalation_not_found PASSED [ 71%]
tests/unit/api/test_escalations.py::TestApproveEscalation::test_approve_already_reviewed PASSED [ 71%]
tests/unit/api/test_escalations.py::TestRejectEscalation::test_reject_escalation_success FAILED [ 72%]
tests/unit/api/test_escalations.py::TestRejectEscalation::test_reject_escalation_not_found PASSED [ 72%]
tests/unit/api/test_feedback.py::TestSubmitFeedback::test_submit_feedback_success PASSED [ 72%]
tests/unit/api/test_feedback.py::TestSubmitFeedback::test_submit_feedback_closed_ticket PASSED [ 72%]
tests/unit/api/test_feedback.py::TestSubmitFeedback::test_submit_feedback_ticket_not_found PASSED [ 72%]
tests/unit/api/test_feedback.py::TestSubmitFeedback::test_submit_feedback_not_reporter PASSED [ 72%]
tests/unit/api/test_feedback.py::TestSubmitFeedback::test_submit_feedback_wrong_status PASSED [ 73%]
tests/unit/api/test_feedback.py::TestSubmitFeedback::test_submit_feedback_already_exists PASSED [ 73%]
tests/unit/api/test_feedback.py::TestGetFeedback::test_get_feedback_success PASSED [ 73%]
tests/unit/api/test_feedback.py::TestGetFeedback::test_get_feedback_not_found PASSED [ 73%]
tests/unit/api/test_notifications.py::TestListNotifications::test_list_notifications_success FAILED [ 73%]
tests/unit/api/test_notifications.py::TestListNotifications::test_list_notifications_unread_only PASSED [ 73%]
tests/unit/api/test_notifications.py::TestGetUnreadCount::test_get_unread_count_with_notifications PASSED [ 73%]
tests/unit/api/test_notifications.py::TestGetUnreadCount::test_get_unread_count_none PASSED [ 74%]
tests/unit/api/test_notifications.py::TestMarkAsRead::test_mark_as_read_success FAILED [ 74%]
tests/unit/api/test_notifications.py::TestMarkAsRead::test_mark_as_read_not_found PASSED [ 74%]
tests/unit/api/test_notifications.py::TestMarkAllAsRead::test_mark_all_as_read_success PASSED [ 74%]
tests/unit/api/test_notifications.py::TestMarkAllAsRead::test_mark_all_as_read_no_notifications PASSED [ 74%]
tests/unit/api/test_teams.py::TestListTeams::test_list_teams_success FAILED [ 74%]
tests/unit/api/test_teams.py::TestListTeams::test_list_teams_empty FAILED [ 75%]
tests/unit/api/test_teams.py::TestGetTeam::test_get_team_success PASSED  [ 75%]
tests/unit/api/test_teams.py::TestGetTeam::test_get_team_not_found PASSED [ 75%]
tests/unit/api/test_teams.py::TestCreateTeam::test_create_team_success FAILED [ 75%]
tests/unit/api/test_teams.py::TestCreateTeam::test_create_team_duplicate_name PASSED [ 75%]
tests/unit/api/test_teams.py::TestUpdateTeam::test_update_team_success PASSED [ 75%]
tests/unit/api/test_teams.py::TestUpdateTeam::test_update_team_not_found PASSED [ 75%]
tests/unit/api/test_teams.py::TestUpdateTeam::test_update_team_duplicate_name PASSED [ 76%]
tests/unit/api/test_teams.py::TestDeleteTeam::test_delete_team_success FAILED [ 76%]
tests/unit/api/test_teams.py::TestDeleteTeam::test_delete_team_not_found PASSED [ 76%]
tests/unit/api/test_teams.py::TestAddTeamMember::test_add_member_success FAILED [ 76%]
tests/unit/api/test_teams.py::TestAddTeamMember::test_add_member_team_not_found PASSED [ 76%]
tests/unit/api/test_teams.py::TestAddTeamMember::test_add_member_user_not_found FAILED [ 76%]
tests/unit/api/test_teams.py::TestRemoveTeamMember::test_remove_member_success FAILED [ 77%]
tests/unit/api/test_teams.py::TestRemoveTeamMember::test_remove_member_not_in_team FAILED [ 77%]
tests/unit/api/test_users.py::TestListUsers::test_list_users_success PASSED [ 77%]
tests/unit/api/test_users.py::TestListUsers::test_list_users_filter_by_role PASSED [ 77%]
tests/unit/api/test_users.py::TestGetUser::test_get_own_user PASSED      [ 77%]
tests/unit/api/test_users.py::TestGetUser::test_manager_can_view_any_user PASSED [ 77%]
tests/unit/api/test_users.py::TestGetUser::test_citizen_cannot_view_other_user PASSED [ 77%]
tests/unit/api/test_users.py::TestGetUser::test_get_nonexistent_user PASSED [ 78%]
tests/unit/api/test_users.py::TestUpdateUser::test_update_own_profile PASSED [ 78%]
tests/unit/api/test_users.py::TestUpdateUser::test_cannot_update_other_user PASSED [ 78%]
tests/unit/api/test_users.py::TestUpdateUser::test_update_phone_conflict PASSED [ 78%]
tests/unit/api/test_users.py::TestUpdateUserRole::test_promote_to_support PASSED [ 78%]
tests/unit/api/test_users.py::TestUpdateUserRole::test_assign_team_with_role PASSED [ 78%]
tests/unit/api/test_users.py::TestUpdateUserRole::test_update_nonexistent_user_role PASSED [ 79%]
tests/unit/api/test_users.py::TestDeleteUser::test_soft_delete_user PASSED [ 79%]
tests/unit/api/test_users.py::TestDeleteUser::test_delete_nonexistent_user PASSED [ 79%]
tests/unit/core/test_permissions.py::TestRoleChecks::test_is_citizen PASSED [ 79%]
tests/unit/core/test_permissions.py::TestRoleChecks::test_is_support PASSED [ 79%]
tests/unit/core/test_permissions.py::TestRoleChecks::test_is_manager PASSED [ 79%]
tests/unit/core/test_permissions.py::TestRoleChecks::test_is_support_or_manager PASSED [ 79%]
tests/unit/core/test_permissions.py::TestPermissionChecks::test_can_manage_tickets PASSED [ 80%]
tests/unit/core/test_permissions.py::TestPermissionChecks::test_can_view_analytics PASSED [ 80%]
tests/unit/core/test_permissions.py::TestPermissionChecks::test_can_approve_escalations PASSED [ 80%]
tests/unit/core/test_permissions.py::TestRequireRolesDecorator::test_require_roles_allows_valid_role PASSED [ 80%]
tests/unit/core/test_permissions.py::TestRequireRolesDecorator::test_require_roles_denies_invalid_role PASSED [ 80%]
tests/unit/core/test_permissions.py::TestRequireRolesDecorator::test_require_roles_denies_unauthenticated_user PASSED [ 80%]
tests/unit/core/test_permissions.py::TestRequireRolesDecorator::test_require_roles_allows_single_role PASSED [ 81%]
tests/unit/core/test_permissions.py::TestRequireRolesDecorator::test_require_roles_preserves_function_return PASSED [ 81%]
tests/unit/core/test_rate_limit.py::TestRateLimitConfig::test_config_creation PASSED [ 81%]
tests/unit/core/test_rate_limit.py::TestInMemoryRateLimiter::test_first_request_not_limited PASSED [ 81%]
tests/unit/core/test_rate_limit.py::TestInMemoryRateLimiter::test_under_limit_not_limited PASSED [ 81%]
tests/unit/core/test_rate_limit.py::TestInMemoryRateLimiter::test_at_limit_becomes_limited PASSED [ 81%]
tests/unit/core/test_rate_limit.py::TestInMemoryRateLimiter::test_different_keys_independent PASSED [ 81%]
tests/unit/core/test_rate_limit.py::TestInMemoryRateLimiter::test_reset_clears_limit PASSED [ 82%]
tests/unit/core/test_rate_limit.py::TestInMemoryRateLimiter::test_reset_nonexistent_key_no_error PASSED [ 82%]
tests/unit/core/test_rate_limit.py::TestInMemoryRateLimiter::test_cleanup_old_requests PASSED [ 82%]
tests/unit/core/test_rate_limit.py::TestGetClientIP::test_get_ip_from_x_forwarded_for PASSED [ 82%]
tests/unit/core/test_rate_limit.py::TestGetClientIP::test_get_ip_from_client_host PASSED [ 82%]
tests/unit/core/test_rate_limit.py::TestGetClientIP::test_get_ip_no_client PASSED [ 82%]
tests/unit/core/test_rate_limit.py::TestGetClientIP::test_get_ip_strips_whitespace PASSED [ 83%]
tests/unit/core/test_rate_limit.py::TestCheckRateLimit::test_check_rate_limit_passes_under_limit PASSED [ 83%]
tests/unit/core/test_rate_limit.py::TestCheckRateLimit::test_check_rate_limit_raises_when_limited PASSED [ 83%]
tests/unit/core/test_rate_limit.py::TestCheckRateLimit::test_check_rate_limit_uses_key_suffix PASSED [ 83%]
tests/unit/core/test_security.py::TestJWTTokens::test_create_access_token PASSED [ 83%]
tests/unit/core/test_security.py::TestJWTTokens::test_create_access_token_with_expiry PASSED [ 83%]
tests/unit/core/test_security.py::TestJWTTokens::test_create_refresh_token PASSED [ 83%]
tests/unit/core/test_security.py::TestJWTTokens::test_decode_valid_token PASSED [ 84%]
tests/unit/core/test_security.py::TestJWTTokens::test_decode_invalid_token PASSED [ 84%]
tests/unit/core/test_security.py::TestJWTTokens::test_decode_expired_token PASSED [ 84%]
tests/unit/core/test_security.py::TestOTPGeneration::test_generate_otp_code PASSED [ 84%]
tests/unit/core/test_security.py::TestOTPGeneration::test_generate_otp_code_uniqueness PASSED [ 84%]
tests/unit/core/test_security.py::TestOTPGeneration::test_get_otp_expiry PASSED [ 84%]
tests/unit/core/test_security.py::TestOTPGeneration::test_get_otp_expiry_is_5_minutes PASSED [ 84%]
tests/unit/core/test_security.py::TestPasswordHashing::test_hash_password PASSED [ 85%]
tests/unit/core/test_security.py::TestPasswordHashing::test_hash_password_produces_different_hashes PASSED [ 85%]
tests/unit/core/test_security.py::TestPasswordHashing::test_verify_password_correct PASSED [ 85%]
tests/unit/core/test_security.py::TestPasswordHashing::test_verify_password_incorrect PASSED [ 85%]
tests/unit/core/test_security.py::TestPasswordHashing::test_verify_password_empty PASSED [ 85%]
tests/unit/core/test_security.py::TestPasswordHashing::test_hash_password_truncates_long_passwords PASSED [ 85%]
tests/unit/core/test_security.py::TestPasswordHashing::test_hash_password_unicode PASSED [ 86%]
tests/unit/services/test_notification_service.py::TestCreateNotification::test_creates_notification_with_all_fields PASSED [ 86%]
tests/unit/services/test_notification_service.py::TestCreateNotification::test_creates_notification_without_ticket_id PASSED [ 86%]
tests/unit/services/test_notification_service.py::TestNotifyTicketCreated::test_notifies_reporter PASSED [ 86%]
tests/unit/services/test_notification_service.py::TestNotifyTicketFollowed::test_notifies_reporter_when_others_follow PASSED [ 86%]
tests/unit/services/test_notification_service.py::TestNotifyTicketFollowed::test_does_not_notify_when_reporter_follows_own_ticket PASSED [ 86%]
tests/unit/services/test_notification_service.py::TestNotifyTicketStatusChanged::test_notifies_reporter_on_status_change PASSED [ 86%]
tests/unit/services/test_notification_service.py::TestNotifyTicketStatusChanged::test_does_not_notify_reporter_if_self_change PASSED [ 87%]
tests/unit/services/test_notification_service.py::TestNotifyTicketStatusChanged::test_notifies_followers_on_status_change PASSED [ 87%]
tests/unit/services/test_notification_service.py::TestNotifyTicketStatusChanged::test_status_labels_in_message PASSED [ 87%]
tests/unit/services/test_sms.py::TestSMSService::test_init_with_twilio_enabled PASSED [ 87%]
tests/unit/services/test_sms.py::TestSMSService::test_init_with_twilio_disabled PASSED [ 87%]
tests/unit/services/test_sms.py::TestSMSService::test_send_otp_disabled PASSED [ 87%]
tests/unit/services/test_sms.py::TestSMSService::test_send_otp_success PASSED [ 88%]
tests/unit/services/test_sms.py::TestSMSService::test_send_ticket_status_update_disabled PASSED [ 88%]
tests/unit/services/test_sms.py::TestSMSService::test_send_ticket_status_update_in_progress PASSED [ 88%]
tests/unit/services/test_sms.py::TestSMSService::test_send_ticket_status_update_unknown_status_uses_raw_value PASSED [ 88%]
tests/unit/services/test_sms.py::TestSMSService::test_send_sms_returns_false_when_client_missing PASSED [ 88%]
tests/unit/services/test_sms.py::TestSMSService::test_send_sms_handles_client_exception PASSED [ 88%]
tests/unit/services/test_sms.py::TestSMSService::test_send_sms_disabled PASSED [ 88%]
tests/unit/services/test_sms.py::TestSMSService::test_send_sms_success PASSED [ 89%]
tests/unit/services/test_storage.py::TestStorageService::test_init PASSED [ 89%]
tests/unit/services/test_storage.py::TestStorageService::test_get_client_creates_client PASSED [ 89%]
tests/unit/services/test_storage.py::TestStorageService::test_get_client_creates_bucket_if_not_exists PASSED [ 89%]
tests/unit/services/test_storage.py::TestStorageService::test_get_client_caches_client PASSED [ 89%]
tests/unit/services/test_storage.py::TestStorageService::test_upload_file_success PASSED [ 89%]
tests/unit/services/test_storage.py::TestStorageService::test_upload_file_with_custom_folder PASSED [ 90%]
tests/unit/services/test_storage.py::TestStorageService::test_upload_file_failure_returns_none PASSED [ 90%]
tests/unit/services/test_storage.py::TestStorageService::test_get_presigned_url_success PASSED [ 90%]
tests/unit/services/test_storage.py::TestStorageService::test_get_presigned_url_with_custom_expiry PASSED [ 90%]
tests/unit/services/test_storage.py::TestStorageService::test_get_presigned_url_failure_returns_none PASSED [ 90%]
tests/unit/services/test_storage.py::TestStorageService::test_delete_file_success PASSED [ 90%]
tests/unit/services/test_storage.py::TestStorageService::test_delete_file_failure_returns_false PASSED [ 90%]
tests/unit/services/test_storage.py::TestStorageService::test_get_public_url PASSED [ 91%]
tests/unit/services/test_storage.py::TestStorageService::test_get_public_url_https PASSED [ 91%]
tests/unit/services/test_storage.py::TestStorageService::test_ensure_bucket_exists_handles_s3_error PASSED [ 91%]
tests/unit/services/test_team_assignment_service.py::TestFindMatchingTeam::test_find_team_by_category_and_district PASSED [ 91%]
tests/unit/services/test_team_assignment_service.py::TestFindMatchingTeam::test_find_team_by_category_in_city PASSED [ 91%]
tests/unit/services/test_team_assignment_service.py::TestFindMatchingTeam::test_find_team_by_category_only PASSED [ 91%]
tests/unit/services/test_team_assignment_service.py::TestFindMatchingTeam::test_no_matching_team_returns_none PASSED [ 92%]
tests/unit/services/test_team_assignment_service.py::TestFindMatchingTeam::test_find_team_without_district PASSED [ 92%]
tests/unit/services/test_team_assignment_service.py::TestGetTeamWorkload::test_workload_counts_active_tickets PASSED [ 92%]
tests/unit/services/test_team_assignment_service.py::TestGetTeamWorkload::test_workload_returns_zero_for_no_tickets PASSED [ 92%]
tests/unit/services/test_team_assignment_service.py::TestGetTeamWorkload::test_workload_excludes_resolved_and_closed PASSED [ 92%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_new_can_transition_to_in_progress PASSED [ 92%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_new_can_transition_to_escalated PASSED [ 92%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_in_progress_can_transition_to_resolved PASSED [ 93%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_in_progress_can_transition_to_escalated PASSED [ 93%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_escalated_can_transition_to_in_progress PASSED [ 93%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_resolved_can_transition_to_closed PASSED [ 93%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_resolved_can_transition_to_in_progress PASSED [ 93%]
tests/unit/services/test_ticket_query_service.py::TestValidTransitions::test_closed_can_transition_to_in_progress PASSED [ 93%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketResponse::test_build_ticket_response_basic PASSED [ 94%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketResponse::test_build_ticket_response_with_photos PASSED [ 94%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketResponse::test_build_ticket_response_with_comments PASSED [ 94%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketResponse::test_build_ticket_response_with_followers PASSED [ 94%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketResponse::test_build_ticket_response_with_team PASSED [ 94%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketResponse::test_build_ticket_response_no_category PASSED [ 94%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketResponse::test_build_ticket_response_no_reporter PASSED [ 94%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_basic PASSED [ 95%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_is_following_true PASSED [ 95%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_is_following_false PASSED [ 95%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_filters_internal_comments_for_citizen PASSED [ 95%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_shows_internal_comments_for_support PASSED [ 95%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_has_feedback PASSED [ 95%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_no_feedback PASSED [ 96%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_has_escalation PASSED [ 96%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_can_escalate_when_no_pending PASSED [ 96%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_cannot_escalate_when_pending PASSED [ 96%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_cannot_escalate_when_approved PASSED [ 96%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_cannot_escalate_without_team PASSED [ 96%]
tests/unit/services/test_ticket_query_service.py::TestBuildTicketDetailResponse::test_build_detail_response_status_logs PASSED [ 96%]
tests/unit/services/test_ticket_service.py::TestTicketServiceCreate::test_create_ticket_validates_category_exists PASSED [ 97%]
tests/unit/services/test_ticket_service.py::TestTicketServiceCreate::test_create_ticket_validates_category_is_active PASSED [ 97%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdate::test_citizen_can_update_own_new_ticket PASSED [ 97%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdate::test_citizen_cannot_update_non_new_ticket PASSED [ 97%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdate::test_citizen_cannot_update_others_ticket PASSED [ 97%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdate::test_support_can_update_any_ticket PASSED [ 97%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdate::test_nobody_can_update_closed_ticket PASSED [ 98%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdate::test_update_with_invalid_category_fails PASSED [ 98%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_to_in_progress FAILED [ 98%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_in_progress_to_resolved FAILED [ 98%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_resolved_to_closed FAILED [ 98%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_resolved_to_in_progress_reopen FAILED [ 98%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_to_escalated FAILED [ 98%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_cannot_jump_to_resolved FAILED [ 99%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_cannot_jump_to_closed FAILED [ 99%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_closed_cannot_change FAILED [ 99%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_in_progress_cannot_jump_to_closed FAILED [ 99%]
tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_status_change_creates_log_entry FAILED [ 99%]
tests/unit/services/test_ticket_service.py::TestTicketServiceAssign::test_assign_ticket_to_valid_team PASSED [ 99%]
tests/unit/services/test_ticket_service.py::TestTicketServiceAssign::test_assign_ticket_to_nonexistent_team_fails PASSED [100%]

=================================== FAILURES ===================================
____ TestTeamPerformanceAnalytics.test_manager_can_access_team_performance _____

self = <tests.integration.analytics.test_analytics.TestTeamPerformanceAnalytics object at 0xffff984982d0>
client = <httpx.AsyncClient object at 0xffff974f6d50>
manager_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJmZDIyY2M2OS1lY2YwLTQ2MDUtOWZkOS0zYmM2MzBmNzY3OGMiLCJleHAiOjE3NjY5MjgxNDcsInR5cGUiOiJhY2Nlc3MifQ.Z--l0lrfdq9vYOX9f2BZmtIlROyuk2bGckIAPCR1l4E'

    async def test_manager_can_access_team_performance(
        self, client: AsyncClient, manager_token: str
    ):
        """Manager should be able to access team performance."""
        response = await client.get(
            "/api/v1/analytics/teams",
            headers=auth_headers(manager_token),
        )
        assert response.status_code == 200
        data = response.json()
>       assert "teams" in data
E       AssertionError: assert 'teams' in {'items': []}

tests/integration/analytics/test_analytics.py:141: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://test/api/v1/analytics/teams "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: GET http://test/api/v1/analytics/teams "HTTP/1.1 200 OK"
_________ TestTeamPerformanceAnalytics.test_team_performance_with_team _________

self = <tests.integration.analytics.test_analytics.TestTeamPerformanceAnalytics object at 0xffff98498e10>
client = <httpx.AsyncClient object at 0xffff976a06e0>
manager_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjNTU2MmIyYy03ZDVlLTRhZTctOTA0Yy1kNzAwZGFlNGQ5YjciLCJleHAiOjE3NjY5MjgxNDcsInR5cGUiOiJhY2Nlc3MifQ.0PLPMRykTyl3yx4Djq_WMwf5tdIpWaMcSZcSzk339Ok'
team = <Team Infrastructure Team>

    async def test_team_performance_with_team(
        self, client: AsyncClient, manager_token: str, team: Team
    ):
        """Team performance should include team data."""
        response = await client.get(
            "/api/v1/analytics/teams",
            headers=auth_headers(manager_token),
        )
        assert response.status_code == 200
        data = response.json()
>       assert len(data["teams"]) >= 1
                   ^^^^^^^^^^^^^
E       KeyError: 'teams'

tests/integration/analytics/test_analytics.py:153: KeyError
----------------------------- Captured stdout call -----------------------------
DEBUG: Team Infrastructure Team (ffde26f1-7d7a-47f5-a48f-09c581b47278) - Members: 0 - IDs: []
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://test/api/v1/analytics/teams "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: GET http://test/api/v1/analytics/teams "HTTP/1.1 200 OK"
___ TestTeamPerformanceAnalytics.test_team_performance_with_assigned_tickets ___

self = <tests.integration.analytics.test_analytics.TestTeamPerformanceAnalytics object at 0xffff984a0180>
client = <httpx.AsyncClient object at 0xffff9765f7a0>
manager_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIyZGFiNTk0My1jMjVhLTQ5ZDItOTA1OC1kMzI0ZTE2MTk4OGUiLCJleHAiOjE3NjY5MjgxNDgsInR5cGUiOiJhY2Nlc3MifQ.GAiqz6b2G6fjIVvXnoRG4FgONEzDp1e1zbaIXC9x20k'
ticket = <Ticket 917c45a4-49bc-42c1-96ba-5fd55ebed194 (NEW)>
team = <Team Infrastructure Team>
support_user_with_team = <User +905551111111 (SUPPORT)>

    async def test_team_performance_with_assigned_tickets(
        self,
        client: AsyncClient,
        manager_token: str,
        ticket: Ticket,
        team: Team,
        support_user_with_team: User,  # Ensure team has a member
    ):
        """Team performance should reflect assigned tickets."""
        response = await client.get(
            "/api/v1/analytics/teams",
            headers=auth_headers(manager_token),
        )
        assert response.status_code == 200
        data = response.json()
        # Find our team in the response
        team_data = next(
>           (t for t in data["teams"] if str(t["team_id"]) == str(team.id)), None
                        ^^^^^^^^^^^^^
        )
E       KeyError: 'teams'

tests/integration/analytics/test_analytics.py:179: KeyError
----------------------------- Captured stdout call -----------------------------
DEBUG: Team Infrastructure Team (3b9d9cf4-5065-43b4-aab5-bea57c4c509f) - Members: 1 - IDs: [UUID('39ab5831-1fe1-4079-aa85-ee09f8f73d6e')]
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://test/api/v1/analytics/teams "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: GET http://test/api/v1/analytics/teams "HTTP/1.1 200 OK"
____________ TestUpdateStatus.test_update_status_creates_status_log ____________

self = <tests.integration.services.test_ticket_service_integration.TestUpdateStatus object at 0xffff983e9f90>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff96216930>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff96418bb0>
ticket = <Ticket 73cd34d0-0f30-4d02-b1db-a4437e480055 (NEW)>
support_user = <User +905559876543 (SUPPORT)>

    async def test_update_status_creates_status_log(
        self,
        db_session: AsyncSession,
        ticket_service: TicketService,
        ticket: Ticket,
        support_user: User,
    ):
        """Should create status log entry on status change."""
        ticket.status = TicketStatus.NEW
        await db_session.commit()
    
>       await ticket_service.update_status(
            db_session,
            ticket,
            TicketStatus.IN_PROGRESS,
            comment="Starting work on this ticket",
            current_user=support_user,
        )

tests/integration/services/test_ticket_service_integration.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff96418bb0>
db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff96216930>
ticket = <Ticket 73cd34d0-0f30-4d02-b1db-a4437e480055 (NEW)>
new_status = <TicketStatus.IN_PROGRESS: 'IN_PROGRESS'>
comment = 'Starting work on this ticket'
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
                raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
            if ticket.team_id != current_user.team_id:
>               raise ForbiddenException(
                    detail="You can only update status of tickets assigned to your team"
                )
E               app.core.exceptions.ForbiddenException: 403: You can only update status of tickets assigned to your team

app/services/ticket_service.py:283: ForbiddenException
_______ TestUpdateStatus.test_update_status_to_resolved_sets_resolved_at _______

self = <tests.integration.services.test_ticket_service_integration.TestUpdateStatus object at 0xffff983ea0d0>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff960ee030>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff960f9550>
ticket = <Ticket c22403f4-35f6-4612-8e06-8a1b9725013d (IN_PROGRESS)>
support_user = <User +905559876543 (SUPPORT)>

    async def test_update_status_to_resolved_sets_resolved_at(
        self,
        db_session: AsyncSession,
        ticket_service: TicketService,
        ticket: Ticket,
        support_user: User,
    ):
        """Should set resolved_at timestamp when status changes to RESOLVED."""
        ticket.status = TicketStatus.IN_PROGRESS
        await db_session.commit()
    
>       updated = await ticket_service.update_status(
            db_session,
            ticket,
            TicketStatus.RESOLVED,
            comment="Issue fixed",
            current_user=support_user,
        )

tests/integration/services/test_ticket_service_integration.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff960f9550>
db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff960ee030>
ticket = <Ticket c22403f4-35f6-4612-8e06-8a1b9725013d (IN_PROGRESS)>
new_status = <TicketStatus.RESOLVED: 'RESOLVED'>, comment = 'Issue fixed'
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
                raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
            if ticket.team_id != current_user.team_id:
>               raise ForbiddenException(
                    detail="You can only update status of tickets assigned to your team"
                )
E               app.core.exceptions.ForbiddenException: 403: You can only update status of tickets assigned to your team

app/services/ticket_service.py:283: ForbiddenException
_________ TestUpdateStatus.test_update_status_invalid_transition_fails _________

self = <tests.integration.services.test_ticket_service_integration.TestUpdateStatus object at 0xffff98394c30>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff9678af90>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff964306d0>
ticket = <Ticket fb6763d1-0a91-45ee-bd51-5343dde4c24e (NEW)>
support_user = <User +905559876543 (SUPPORT)>

    async def test_update_status_invalid_transition_fails(
        self,
        db_session: AsyncSession,
        ticket_service: TicketService,
        ticket: Ticket,
        support_user: User,
    ):
        """Should raise exception for invalid status transition."""
        from app.core.exceptions import InvalidStatusTransitionException
    
        ticket.status = TicketStatus.NEW
        await db_session.commit()
    
        # NEW -> CLOSED is not a valid transition
        with pytest.raises(InvalidStatusTransitionException):
>           await ticket_service.update_status(
                db_session,
                ticket,
                TicketStatus.CLOSED,
                comment=None,
                current_user=support_user,
            )

tests/integration/services/test_ticket_service_integration.py:464: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff964306d0>
db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff9678af90>
ticket = <Ticket fb6763d1-0a91-45ee-bd51-5343dde4c24e (NEW)>
new_status = <TicketStatus.CLOSED: 'CLOSED'>, comment = None
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
                raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
            if ticket.team_id != current_user.team_id:
>               raise ForbiddenException(
                    detail="You can only update status of tickets assigned to your team"
                )
E               app.core.exceptions.ForbiddenException: 403: You can only update status of tickets assigned to your team

app/services/ticket_service.py:283: ForbiddenException
____________ TestUpdateStatus.test_update_status_notifies_reporter _____________

self = <tests.integration.services.test_ticket_service_integration.TestUpdateStatus object at 0xffff98394d60>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff96215130>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff96b9f410>
ticket = <Ticket d03555cc-ff1b-4ed5-bbe7-f1ec52bd5e4c (NEW)>
support_user = <User +905559876543 (SUPPORT)>
citizen_user = <User +905551234567 (CITIZEN)>

    async def test_update_status_notifies_reporter(
        self,
        db_session: AsyncSession,
        ticket_service: TicketService,
        ticket: Ticket,
        support_user: User,
        citizen_user: User,
    ):
        """Should notify reporter when status changes (if changed by someone else)."""
        ticket.status = TicketStatus.NEW
        ticket.reporter_id = citizen_user.id
        await db_session.commit()
    
>       await ticket_service.update_status(
            db_session,
            ticket,
            TicketStatus.IN_PROGRESS,
            comment="Working on it",
            current_user=support_user,
        )

tests/integration/services/test_ticket_service_integration.py:485: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff96b9f410>
db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff96215130>
ticket = <Ticket d03555cc-ff1b-4ed5-bbe7-f1ec52bd5e4c (NEW)>
new_status = <TicketStatus.IN_PROGRESS: 'IN_PROGRESS'>
comment = 'Working on it', current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
                raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
            if ticket.team_id != current_user.team_id:
>               raise ForbiddenException(
                    detail="You can only update status of tickets assigned to your team"
                )
E               app.core.exceptions.ForbiddenException: 403: You can only update status of tickets assigned to your team

app/services/ticket_service.py:283: ForbiddenException
______ TestTicketManagementPermissions.test_support_can_manage_any_ticket ______

self = <tests.integration.test_permissions_integration.TestTicketManagementPermissions object at 0xffff98256710>
client = <httpx.AsyncClient object at 0xffff9765a810>
ticket = <Ticket 5572e7e9-dfa8-4381-9fc7-7dedfdb62bf4 (NEW)>
support_other_team_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNWI2NTg5NC0zMjlkLTRkMGYtYmIzMS05OTY3NWMyMDQ5ODMiLCJleHAiOjE3NjY5MjgxNzQsInR5cGUiOiJhY2Nlc3MifQ.3yh9ZMeH2lIHpIYrGV-fnL5Nha8SUycS3mEHSPA-31w'

    async def test_support_can_manage_any_ticket(
        self,
        client: AsyncClient,
        ticket: Ticket,
        support_other_team_token: str,
    ):
        """Support user can manage any ticket (no team restriction currently implemented)."""
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            headers=auth_headers(support_other_team_token),
            json={"status": "IN_PROGRESS"},
        )
        # Currently, support users can manage any ticket regardless of team assignment
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/test_permissions_integration.py:166: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/5572e7e9-dfa8-4381-9fc7-7dedfdb62bf4/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/5572e7e9-dfa8-4381-9fc7-7dedfdb62bf4/status "HTTP/1.1 403 Forbidden"
____________________ TestListTeams.test_manager_lists_teams ____________________

self = <tests.integration.test_teams.TestListTeams object at 0xffff98256d50>
client = <httpx.AsyncClient object at 0xffff96b9c050>
manager_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1NDMyNTZhZS01MWJkLTQ5ZjYtYTkzMS1lZmYwYzY5MzlmODgiLCJleHAiOjE3NjY5MjgxNzUsInR5cGUiOiJhY2Nlc3MifQ.2p51dIlLouX5fy97tkgNZxMAeUHRPjbxuWMemHPTx9Q'
team = <Team Infrastructure Team>

    async def test_manager_lists_teams(
        self, client: AsyncClient, manager_token: str, team
    ):
        """Manager should be able to list teams."""
        response = await client.get(
            "/api/v1/teams",
            headers=auth_headers(manager_token),
        )
        assert response.status_code == 200
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'items': [{'active_ticket_count': 0, 'created_at': '2025-12-28T13:07:55.735183Z', 'description': 'Handles infrastructure issues', 'district_ids': [], ...}], 'page': 1, 'page_size': 20, 'total': 1}, list)

tests/integration/test_teams.py:39: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://test/api/v1/teams "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: GET http://test/api/v1/teams "HTTP/1.1 200 OK"
________________ TestStatusTransitions.test_new_to_in_progress _________________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff98292d50>
client = <httpx.AsyncClient object at 0xffff954d7650>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIzNzEyODRjYy02MDNhLTQxYzYtYTY0NS0yZWMxN2E2ZTliNTEiLCJleHAiOjE3NjY5MjgxOTYsInR5cGUiOiJhY2Nlc3MifQ.JsH8NoYYsvbWB9lRXEcnhRFK9FdHBIHo7ACL1AZr2N8'
ticket = <Ticket 04c8c989-f0bd-4933-90d2-daa2fd85d1fc (NEW)>

    async def test_new_to_in_progress(
        self, client: AsyncClient, support_token: str, ticket
    ):
        """NEW -> IN_PROGRESS is a valid transition."""
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "IN_PROGRESS"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:28: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/04c8c989-f0bd-4933-90d2-daa2fd85d1fc/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/04c8c989-f0bd-4933-90d2-daa2fd85d1fc/status "HTTP/1.1 403 Forbidden"
______________ TestStatusTransitions.test_in_progress_to_resolved ______________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff98292c10>
client = <httpx.AsyncClient object at 0xffff94b8b350>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI4OTRjYzYwOC02MmU5LTQ0MzAtYTcwOC1hYWIzNDVmMDQ1NmUiLCJleHAiOjE3NjY5MjgxOTcsInR5cGUiOiJhY2Nlc3MifQ.XRdkElQyoDZzFih54vHBaAls1nP2iL3XE_7BtjjIPD8'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff9476f5f0>
ticket = <Ticket b9a5766b-b267-4377-a7e8-e8cb057db7b2 (IN_PROGRESS)>

    async def test_in_progress_to_resolved(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """IN_PROGRESS -> RESOLVED is a valid transition."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.IN_PROGRESS
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "RESOLVED", "comment": "Issue has been fixed"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:46: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/b9a5766b-b267-4377-a7e8-e8cb057db7b2/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/b9a5766b-b267-4377-a7e8-e8cb057db7b2/status "HTTP/1.1 403 Forbidden"
________________ TestStatusTransitions.test_resolved_to_closed _________________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff982adba0>
client = <httpx.AsyncClient object at 0xffff94b89fd0>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkODVjYzMyZS0wNWQ1LTQ0MTUtOGY1My00NTFmMzI4ZWZjODEiLCJleHAiOjE3NjY5MjgxOTcsInR5cGUiOiJhY2Nlc3MifQ.4BodJ9JM0NJEBEAM2IEKjOdvGDwplazaIuHOWrJqA44'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff946de3f0>
ticket = <Ticket b12a97ea-e70b-4089-a4a4-79168afec065 (RESOLVED)>

    async def test_resolved_to_closed(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """RESOLVED -> CLOSED is a valid transition."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.RESOLVED
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "CLOSED"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:64: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/b12a97ea-e70b-4089-a4a4-79168afec065/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/b12a97ea-e70b-4089-a4a4-79168afec065/status "HTTP/1.1 403 Forbidden"
__________ TestStatusTransitions.test_resolved_to_in_progress_reopen ___________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff982adcd0>
client = <httpx.AsyncClient object at 0xffff954d7b90>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIzMDk1OWE1ZC04ZWVhLTQwOTktOGQyMi0xMjYxNTliODNhYmYiLCJleHAiOjE3NjY5MjgxOTcsInR5cGUiOiJhY2Nlc3MifQ.muMtXrlRB9LCdTZPDK-AoycUV_lWocSSIUdC9NIouQI'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff953b2570>
ticket = <Ticket 3d244a9c-c2c7-4894-a8b1-59ce0ec49a45 (RESOLVED)>

    async def test_resolved_to_in_progress_reopen(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """RESOLVED -> IN_PROGRESS (reopen) is a valid transition."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.RESOLVED
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={
                "status": "IN_PROGRESS",
                "comment": "Reopening - issue not fully fixed",
            },
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:85: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/3d244a9c-c2c7-4894-a8b1-59ce0ec49a45/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/3d244a9c-c2c7-4894-a8b1-59ce0ec49a45/status "HTTP/1.1 403 Forbidden"
_________________ TestStatusTransitions.test_new_to_escalated __________________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff982c9130>
client = <httpx.AsyncClient object at 0xffff9765bc50>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIzOTFkYWNjMy1lMjAwLTQ4NGEtYjJjNy1iZjcxNDgyNzdkYzIiLCJleHAiOjE3NjY5MjgxOTgsInR5cGUiOiJhY2Nlc3MifQ.s7UOc6pXtfYNL8sv9qbel89UFG9GNIZmPd1Sl7Dn2rE'
ticket = <Ticket 76726c08-5524-490f-9f31-06fa1ca7b88f (NEW)>

    async def test_new_to_escalated(
        self, client: AsyncClient, support_token: str, ticket
    ):
        """NEW -> ESCALATED is a valid transition."""
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "ESCALATED", "comment": "Needs manager review"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:98: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/76726c08-5524-490f-9f31-06fa1ca7b88f/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/76726c08-5524-490f-9f31-06fa1ca7b88f/status "HTTP/1.1 403 Forbidden"
_____________ TestStatusTransitions.test_in_progress_to_escalated ______________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff983d3020>
client = <httpx.AsyncClient object at 0xffff954d6510>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJlYjRhNjI5Ni0yNDUwLTRmMzUtOWFhYi1iYjc1YjgzMjcxMzgiLCJleHAiOjE3NjY5MjgxOTgsInR5cGUiOiJhY2Nlc3MifQ.7kv8VfeVL3cKMfBtuFj0aUBEWu48c95TRgaVhf5ldVo'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff94460f50>
ticket = <Ticket 37253438-1f3a-4329-aed6-9a39e59f1d5a (IN_PROGRESS)>

    async def test_in_progress_to_escalated(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """IN_PROGRESS -> ESCALATED is a valid transition."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.IN_PROGRESS
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "ESCALATED"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:116: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/37253438-1f3a-4329-aed6-9a39e59f1d5a/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/37253438-1f3a-4329-aed6-9a39e59f1d5a/status "HTTP/1.1 403 Forbidden"
_____________ TestStatusTransitions.test_escalated_to_in_progress ______________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff983d3130>
client = <httpx.AsyncClient object at 0xffff97659a90>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI2MzNkMDBiMC04ZGNmLTQ1MTQtYjJlMy00NWIzMmMxODM1ZDQiLCJleHAiOjE3NjY5MjgxOTgsInR5cGUiOiJhY2Nlc3MifQ.eoEfzRjz8ezp8qLTjpdl-tZNwJiFXod6hF4soZYnRU0'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff944de690>
ticket = <Ticket 1d690d60-5aa3-40d5-84fd-c7bee824911f (ESCALATED)>

    async def test_escalated_to_in_progress(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """ESCALATED -> IN_PROGRESS is a valid transition (after review)."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.ESCALATED
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={
                "status": "IN_PROGRESS",
                "comment": "Escalation reviewed, continuing work",
            },
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:137: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/1d690d60-5aa3-40d5-84fd-c7bee824911f/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/1d690d60-5aa3-40d5-84fd-c7bee824911f/status "HTTP/1.1 403 Forbidden"
____________ TestStatusTransitions.test_new_cannot_jump_to_resolved ____________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff983c1c50>
client = <httpx.AsyncClient object at 0xffff9765b290>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkNTg1YWU3OS01NjI0LTRiMGQtODlmZi00OGQ1MmY5NDBjZWEiLCJleHAiOjE3NjY5MjgxOTgsInR5cGUiOiJhY2Nlc3MifQ.bQOR3Y5U_SLrDsrtB-Tc96QPsEk3qRtRr0o_XnQ6B_E'
ticket = <Ticket 8e08529e-b45a-486a-bac3-70dc90a0e680 (NEW)>

    async def test_new_cannot_jump_to_resolved(
        self, client: AsyncClient, support_token: str, ticket
    ):
        """NEW -> RESOLVED is NOT a valid transition."""
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "RESOLVED"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 400
E       assert 403 == 400
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:151: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/8e08529e-b45a-486a-bac3-70dc90a0e680/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/8e08529e-b45a-486a-bac3-70dc90a0e680/status "HTTP/1.1 403 Forbidden"
_____________ TestStatusTransitions.test_new_cannot_jump_to_closed _____________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff983c1d50>
client = <httpx.AsyncClient object at 0xffff96b9d6d0>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5N2RkODExMS00YTBkLTQwZmItOGY4Mi1lMWJhZDk2ZDNiN2MiLCJleHAiOjE3NjY5MjgxOTksInR5cGUiOiJhY2Nlc3MifQ.Mq0120ufb_10rp9p8iK5X-nM3G1ykpftvljkYuGLnhQ'
ticket = <Ticket bf22c9da-a66a-4c02-aef8-2fbba0b303e5 (NEW)>

    async def test_new_cannot_jump_to_closed(
        self, client: AsyncClient, support_token: str, ticket
    ):
        """NEW -> CLOSED is NOT a valid transition."""
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "CLOSED"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 400
E       assert 403 == 400
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:163: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/bf22c9da-a66a-4c02-aef8-2fbba0b303e5/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/bf22c9da-a66a-4c02-aef8-2fbba0b303e5/status "HTTP/1.1 403 Forbidden"
_______________ TestStatusTransitions.test_closed_cannot_change ________________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff98391a90>
client = <httpx.AsyncClient object at 0xffff954d6d50>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5MTg0ZTEzOC1mN2FjLTQ2ZDAtYTg5MS1hNTNjNWE1YTgzNjYiLCJleHAiOjE3NjY5MjgxOTksInR5cGUiOiJhY2Nlc3MifQ.ngPrU8qG9wytuxbUgRzcRRqL9mhNPGtYXEZLRQ5Ae6U'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff95638650>
ticket = <Ticket 8dbb1899-a305-4e45-b693-0a8b522dd84f (CLOSED)>

    async def test_closed_cannot_change(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """CLOSED tickets cannot transition to any other state."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.CLOSED
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "IN_PROGRESS"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 400
E       assert 403 == 400
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:179: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/8dbb1899-a305-4e45-b693-0a8b522dd84f/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/8dbb1899-a305-4e45-b693-0a8b522dd84f/status "HTTP/1.1 403 Forbidden"
_________ TestStatusTransitions.test_in_progress_cannot_jump_to_closed _________

self = <tests.integration.tickets.test_ticket_status.TestStatusTransitions object at 0xffff98391b80>
client = <httpx.AsyncClient object at 0xffff96b9d190>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI3ZWRjN2I4ZS03YmJmLTQzMWMtOTQ0YS03MTUyZTNjMDZmNjAiLCJleHAiOjE3NjY5MjgxOTksInR5cGUiOiJhY2Nlc3MifQ.asweAs_I_VHoMNciZQaVU5gCpCnqaGljBYVWkvMFDh4'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff94d7d850>
ticket = <Ticket 56376ade-678c-40f2-ba81-a11b8bb101d8 (IN_PROGRESS)>

    async def test_in_progress_cannot_jump_to_closed(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """IN_PROGRESS -> CLOSED is NOT a valid transition (must resolve first)."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.IN_PROGRESS
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "CLOSED"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 400
E       assert 403 == 400
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:195: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/56376ade-678c-40f2-ba81-a11b8bb101d8/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/56376ade-678c-40f2-ba81-a11b8bb101d8/status "HTTP/1.1 403 Forbidden"
_____________ TestStatusPermissions.test_support_can_change_status _____________

self = <tests.integration.tickets.test_ticket_status.TestStatusPermissions object at 0xffff98292fd0>
client = <httpx.AsyncClient object at 0xffff96b9f110>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIyZjU0NGFiZS1iOTA5LTRkYWEtYTdhZi04ZjRmYjgxMTBiNDkiLCJleHAiOjE3NjY5MjgyMDAsInR5cGUiOiJhY2Nlc3MifQ.PiZV-r7-ZNybbwvM5fI7DOdG_rxO2qLHe6GS6085yBI'
ticket = <Ticket aebdb6c4-6b21-4dff-8e17-df4929fc1b70 (NEW)>

    async def test_support_can_change_status(
        self, client: AsyncClient, support_token: str, ticket
    ):
        """Support users can change ticket status."""
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "IN_PROGRESS"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:221: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/aebdb6c4-6b21-4dff-8e17-df4929fc1b70/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/aebdb6c4-6b21-4dff-8e17-df4929fc1b70/status "HTTP/1.1 403 Forbidden"
_____________ TestStatusSideEffects.test_resolved_sets_resolved_at _____________

self = <tests.integration.tickets.test_ticket_status.TestStatusSideEffects object at 0xffff98293110>
client = <httpx.AsyncClient object at 0xffff96b9c350>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5YmY3MTcyNC02MzZlLTQzMzQtOTVkZC1mYTk4ZDU2NDgyOGEiLCJleHAiOjE3NjY5MjgyMDAsInR5cGUiOiJhY2Nlc3MifQ.TiZ3tbJQ3muVN6nCfO0mJtQetiU5ZiU9l9fBOqwabqs'
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff9677df70>
ticket = <Ticket 6811b8ed-209e-4657-8449-3deb968501ba (IN_PROGRESS)>

    async def test_resolved_sets_resolved_at(
        self, client: AsyncClient, support_token: str, db_session, ticket
    ):
        """Resolving a ticket should set resolved_at timestamp."""
        from app.models.ticket import TicketStatus
    
        ticket.status = TicketStatus.IN_PROGRESS
        await db_session.commit()
    
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "RESOLVED", "comment": "Fixed"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:262: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/6811b8ed-209e-4657-8449-3deb968501ba/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/6811b8ed-209e-4657-8449-3deb968501ba/status "HTTP/1.1 403 Forbidden"
____________ TestStatusSideEffects.test_status_change_with_comment _____________

self = <tests.integration.tickets.test_ticket_status.TestStatusSideEffects object at 0xffff98293250>
client = <httpx.AsyncClient object at 0xffff96b9d310>
support_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJmOWU1ZjUyOC1kYzA3LTQ0YjYtOGVmYy0xNjgzN2NmZGVkMTMiLCJleHAiOjE3NjY5MjgyMDEsInR5cGUiOiJhY2Nlc3MifQ.kwMH0C_eZMd1Y6RqNkjgAEhRRAt01pGTYUzAKxHCfCM'
ticket = <Ticket a36a20f5-1c45-45f0-a4c1-ca228579d8c6 (NEW)>

    async def test_status_change_with_comment(
        self, client: AsyncClient, support_token: str, ticket
    ):
        """Status changes can include a comment."""
        response = await client.patch(
            f"/api/v1/tickets/{ticket.id}/status",
            json={"status": "IN_PROGRESS", "comment": "Starting to work on this issue"},
            headers=auth_headers(support_token),
        )
>       assert response.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/tickets/test_ticket_status.py:275: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PATCH http://test/api/v1/tickets/a36a20f5-1c45-45f0-a4c1-ca228579d8c6/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: PATCH http://test/api/v1/tickets/a36a20f5-1c45-45f0-a4c1-ca228579d8c6/status "HTTP/1.1 403 Forbidden"
_____________ test_support_creates_escalation_for_own_team_ticket ______________

client = <httpx.AsyncClient object at 0xffff954d6e10>
ticket = <Ticket 82b70ed5-8b11-40cb-b582-04e31c814c42 (NEW)>
support_with_team_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI4NzVhOWE1OS04NTU3LTQwMTUtOTE5OS1kNWRlYjZkN2UzNjciLCJleHAiOjE3NjY5MjgyMTAsInR5cGUiOiJhY2Nlc3MifQ.HnqAJauWjeVn7VzX-wF_WR9GBgCJyrkYcsXEPliBiLA'

    @pytest.mark.asyncio
    async def test_support_creates_escalation_for_own_team_ticket(
        client: AsyncClient,
        ticket,
        support_with_team_token: str,
    ):
        """Support user can create escalation for their team's ticket."""
>       response = await client.post(
            "/api/v1/escalations",
            json={"ticket_id": str(ticket.id), "reason": "Need manager approval for this issue"},
            headers=auth_headers(support_with_team_token),
        )

tests/test_escalations.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/httpx/_client.py:1859: in post
    return await self.request(
.venv/lib/python3.13/site-packages/httpx/_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
.venv/lib/python3.13/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
.venv/lib/python3.13/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_transports/asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/fastapi/applications.py:1139: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/applications.py:107: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:186: in __call__
    raise exc
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:164: in __call__
    await self.app(scope, receive, _send)
.venv/lib/python3.13/site-packages/starlette/middleware/cors.py:85: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.13/site-packages/fastapi/middleware/asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:736: in app
    await route.handle(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:290: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/fastapi/routing.py:119: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.13/site-packages/fastapi/routing.py:105: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/fastapi/routing.py:385: in app
    raw_response = await run_endpoint_function(
.venv/lib/python3.13/site-packages/fastapi/routing.py:284: in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = EscalationCreate(ticket_id=UUID('82b70ed5-8b11-40cb-b582-04e31c814c42'), reason='Need manager approval for this issue')
current_user = <User +905551111111 (SUPPORT)>
db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff9679f590>

    @router.post(
        "",
        response_model=EscalationResponse,
        status_code=status.HTTP_201_CREATED,
    )
    async def create_escalation(
        request: EscalationCreate,
        current_user: SupportUser,
        db: DatabaseSession,
    ) -> EscalationResponse:
        """Create an escalation request (support only)."""
        # Verify ticket exists and load escalations
        result = await db.execute(
            select(Ticket)
            .options(selectinload(Ticket.escalations))
            .where(Ticket.id == request.ticket_id, Ticket.deleted_at.is_(None))
        )
        ticket = result.scalar_one_or_none()
    
        if ticket is None:
            raise TicketNotFoundException()
    
        # Check if ticket is assigned to a team
        if ticket.team_id is None:
            raise ForbiddenException(detail="Cannot escalate unassigned tickets")
    
        # Check if support user belongs to the ticket's team
        if ticket.team_id != current_user.team_id:
            raise ForbiddenException(
                detail="You can only escalate tickets assigned to your team"
            )
    
        # Check for existing escalations that block new creation
        has_pending = any(e.status == EscalationStatus.PENDING for e in ticket.escalations)
        has_approved = any(
            e.status == EscalationStatus.APPROVED for e in ticket.escalations
        )
    
        if has_pending:
            raise EscalationAlreadyExistsException()
    
        if has_approved:
            raise ForbiddenException(detail="Ticket escalation already approved")
    
        # Create escalation (allowed if no escalations or only rejected ones exist)
        escalation = EscalationRequest(
            ticket_id=request.ticket_id,
            requester_id=current_user.id,
            reason=request.reason,
            status=EscalationStatus.PENDING,
        )
        db.add(escalation)
    
        # Update ticket status
        old_status = ticket.status
        ticket.status = TicketStatus.ESCALATED
    
        # Create status log
        status_log = StatusLog(
            ticket_id=ticket.id,
            old_status=old_status.value,
            new_status=TicketStatus.ESCALATED.value,
            changed_by_id=current_user.id,
            comment=f"Escalated: {request.reason[:100]}",
        )
        db.add(status_log)
    
        await db.commit()
        await db.refresh(escalation)
    
        # Load relationships
        result = await db.execute(
            select(EscalationRequest)
            .options(
                joinedload(EscalationRequest.ticket),
                joinedload(EscalationRequest.requester),
            )
            .where(EscalationRequest.id == escalation.id)
        )
        escalation = result.scalar_one()
    
        # Build response first
        response = _build_escalation_response(escalation)
    
        # Send notification to managers (after response is built)
>       from app.services.notification_service import notify_escalation_requested
E       ImportError: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)

app/api/v1/escalations.py:133: ImportError
----------------------------- Captured stderr call -----------------------------
ERROR:main:Unexpected error: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
Traceback (most recent call last):
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/errors.py", line 164, in __call__
    await self.app(scope, receive, _send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/exceptions.py", line 63, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/middleware/asyncexitstack.py", line 18, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 716, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 736, in app
    await route.handle(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 290, in handle
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 119, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 105, in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 385, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<3 lines>...
    )
    ^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 284, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app/api/v1/escalations.py", line 133, in create_escalation
    from app.services.notification_service import notify_escalation_requested
ImportError: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
------------------------------ Captured log call -------------------------------
ERROR    main:main.py:107 Unexpected error: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
Traceback (most recent call last):
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/errors.py", line 164, in __call__
    await self.app(scope, receive, _send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/exceptions.py", line 63, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/middleware/asyncexitstack.py", line 18, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 716, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 736, in app
    await route.handle(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 290, in handle
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 119, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 105, in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 385, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<3 lines>...
    )
    ^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 284, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app/api/v1/escalations.py", line 133, in create_escalation
    from app.services.notification_service import notify_escalation_requested
ImportError: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
_____________________ test_can_reescalate_after_rejection ______________________

client = <httpx.AsyncClient object at 0xffff94b890d0>
rejected_escalation = <EscalationRequest a77238fd-e62d-4911-b098-aadf925888d8 (REJECTED)>
support_with_team_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1YjU4OTFhOS0zYWY5LTQyZGItODQzZC0wYTM3MTU4ZTMwNTAiLCJleHAiOjE3NjY5MjgyMTIsInR5cGUiOiJhY2Nlc3MifQ.gTNhepWnMfTsZuC9hclolGfG2ovjoUh_r_qvyY5QMfk'

    @pytest.mark.asyncio
    async def test_can_reescalate_after_rejection(
        client: AsyncClient,
        rejected_escalation,
        support_with_team_token: str,
    ):
        """Can create a new escalation after the previous one was rejected."""
>       response = await client.post(
            "/api/v1/escalations",
            json={"ticket_id": str(rejected_escalation.ticket_id), "reason": "Re-escalating after rejection"},
            headers=auth_headers(support_with_team_token),
        )

tests/test_escalations.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/httpx/_client.py:1859: in post
    return await self.request(
.venv/lib/python3.13/site-packages/httpx/_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
.venv/lib/python3.13/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
.venv/lib/python3.13/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_transports/asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/fastapi/applications.py:1139: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/applications.py:107: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:186: in __call__
    raise exc
.venv/lib/python3.13/site-packages/starlette/middleware/errors.py:164: in __call__
    await self.app(scope, receive, _send)
.venv/lib/python3.13/site-packages/starlette/middleware/cors.py:85: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/middleware/exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.13/site-packages/fastapi/middleware/asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:736: in app
    await route.handle(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/routing.py:290: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.13/site-packages/fastapi/routing.py:119: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.13/site-packages/fastapi/routing.py:105: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/fastapi/routing.py:385: in app
    raw_response = await run_endpoint_function(
.venv/lib/python3.13/site-packages/fastapi/routing.py:284: in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = EscalationCreate(ticket_id=UUID('69cee605-be18-47cb-b7f9-570c806bc695'), reason='Re-escalating after rejection')
current_user = <User +905551111111 (SUPPORT)>
db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xffff95220830>

    @router.post(
        "",
        response_model=EscalationResponse,
        status_code=status.HTTP_201_CREATED,
    )
    async def create_escalation(
        request: EscalationCreate,
        current_user: SupportUser,
        db: DatabaseSession,
    ) -> EscalationResponse:
        """Create an escalation request (support only)."""
        # Verify ticket exists and load escalations
        result = await db.execute(
            select(Ticket)
            .options(selectinload(Ticket.escalations))
            .where(Ticket.id == request.ticket_id, Ticket.deleted_at.is_(None))
        )
        ticket = result.scalar_one_or_none()
    
        if ticket is None:
            raise TicketNotFoundException()
    
        # Check if ticket is assigned to a team
        if ticket.team_id is None:
            raise ForbiddenException(detail="Cannot escalate unassigned tickets")
    
        # Check if support user belongs to the ticket's team
        if ticket.team_id != current_user.team_id:
            raise ForbiddenException(
                detail="You can only escalate tickets assigned to your team"
            )
    
        # Check for existing escalations that block new creation
        has_pending = any(e.status == EscalationStatus.PENDING for e in ticket.escalations)
        has_approved = any(
            e.status == EscalationStatus.APPROVED for e in ticket.escalations
        )
    
        if has_pending:
            raise EscalationAlreadyExistsException()
    
        if has_approved:
            raise ForbiddenException(detail="Ticket escalation already approved")
    
        # Create escalation (allowed if no escalations or only rejected ones exist)
        escalation = EscalationRequest(
            ticket_id=request.ticket_id,
            requester_id=current_user.id,
            reason=request.reason,
            status=EscalationStatus.PENDING,
        )
        db.add(escalation)
    
        # Update ticket status
        old_status = ticket.status
        ticket.status = TicketStatus.ESCALATED
    
        # Create status log
        status_log = StatusLog(
            ticket_id=ticket.id,
            old_status=old_status.value,
            new_status=TicketStatus.ESCALATED.value,
            changed_by_id=current_user.id,
            comment=f"Escalated: {request.reason[:100]}",
        )
        db.add(status_log)
    
        await db.commit()
        await db.refresh(escalation)
    
        # Load relationships
        result = await db.execute(
            select(EscalationRequest)
            .options(
                joinedload(EscalationRequest.ticket),
                joinedload(EscalationRequest.requester),
            )
            .where(EscalationRequest.id == escalation.id)
        )
        escalation = result.scalar_one()
    
        # Build response first
        response = _build_escalation_response(escalation)
    
        # Send notification to managers (after response is built)
>       from app.services.notification_service import notify_escalation_requested
E       ImportError: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)

app/api/v1/escalations.py:133: ImportError
----------------------------- Captured stderr call -----------------------------
ERROR:main:Unexpected error: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
Traceback (most recent call last):
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/errors.py", line 164, in __call__
    await self.app(scope, receive, _send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/exceptions.py", line 63, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/middleware/asyncexitstack.py", line 18, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 716, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 736, in app
    await route.handle(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 290, in handle
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 119, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 105, in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 385, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<3 lines>...
    )
    ^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 284, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app/api/v1/escalations.py", line 133, in create_escalation
    from app.services.notification_service import notify_escalation_requested
ImportError: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
------------------------------ Captured log call -------------------------------
ERROR    main:main.py:107 Unexpected error: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
Traceback (most recent call last):
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/errors.py", line 164, in __call__
    await self.app(scope, receive, _send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/middleware/exceptions.py", line 63, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/middleware/asyncexitstack.py", line 18, in __call__
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 716, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 736, in app
    await route.handle(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/routing.py", line 290, in handle
    await self.app(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 119, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/app/.venv/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 105, in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 385, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<3 lines>...
    )
    ^
  File "/app/.venv/lib/python3.13/site-packages/fastapi/routing.py", line 284, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/app/api/v1/escalations.py", line 133, in create_escalation
    from app.services.notification_service import notify_escalation_requested
ImportError: cannot import name 'notify_escalation_requested' from 'app.services.notification_service' (/app/app/services/notification_service.py)
___________ TestGetTeamPerformance.test_team_performance_with_teams ____________

self = <AsyncMock name='mock.execute' id='281473088389200'>
args = (<sqlalchemy.sql.selectable.Select object at 0xffff8fd528d0>,)
kwargs = {}
_call = call(<sqlalchemy.sql.selectable.Select object at 0xffff8fd528d0>)
effect = <list_iterator object at 0xffff950085b0>

    async def _execute_mock_call(self, /, *args, **kwargs):
        # This is nearly just like super(), except for special handling
        # of coroutines
    
        _call = _Call((args, kwargs), two=True)
        self.await_count += 1
        self.await_args = _call
        self.await_args_list.append(_call)
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
                try:
>                   result = next(effect)
                             ^^^^^^^^^^^^
E                   StopIteration

/usr/local/lib/python3.13/unittest/mock.py:2324: StopIteration

During handling of the above exception, another exception occurred:

self = <tests.unit.api.test_analytics.TestGetTeamPerformance object at 0xffff98190410>
mock_db = <AsyncMock id='281473088306352'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_team_performance_with_teams(self, mock_db, manager_user):
        """Should return performance metrics for all teams."""
        team = Team(id=uuid.uuid4(), name="Infrastructure Team")
    
        # Mock teams query
        mock_teams = MagicMock()
        mock_scalars = MagicMock()
        mock_scalars.all.return_value = [team]
        mock_teams.scalars.return_value = mock_scalars
    
        # Mock member IDs query
        mock_members = MagicMock()
        mock_members.all.return_value = [(uuid.uuid4(),)]
    
        # Mock total assigned
        mock_assigned = MagicMock()
        mock_assigned.scalar.return_value = 50
    
        # Mock total resolved
        mock_resolved = MagicMock()
        mock_resolved.scalar.return_value = 40
    
        # Mock avg resolution time
        mock_avg_time = MagicMock()
        mock_avg_time.scalar.return_value = 12.5
    
        # Mock avg rating
        mock_avg_rating = MagicMock()
        mock_avg_rating.scalar.return_value = 4.2
    
        mock_db.execute.side_effect = [
            mock_teams,
            mock_members,
            mock_assigned,
            mock_resolved,
            mock_avg_time,
            mock_avg_rating,
        ]
    
>       result = await get_team_performance(mock_db, manager_user, days=30)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/api/test_analytics.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/v1/analytics.py:324: in get_team_performance
    avg_rating_result = await db.execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncMock name='mock.execute' id='281473088389200'>
args = (<sqlalchemy.sql.selectable.Select object at 0xffff8fd528d0>,)
kwargs = {}
_call = call(<sqlalchemy.sql.selectable.Select object at 0xffff8fd528d0>)
effect = <list_iterator object at 0xffff950085b0>

    async def _execute_mock_call(self, /, *args, **kwargs):
        # This is nearly just like super(), except for special handling
        # of coroutines
    
        _call = _Call((args, kwargs), two=True)
        self.await_count += 1
        self.await_args = _call
        self.await_args_list.append(_call)
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
                try:
                    result = next(effect)
                except StopIteration:
                    # It is impossible to propagate a StopIteration
                    # through coroutines because of PEP 479
>                   raise StopAsyncIteration
E                   StopAsyncIteration

/usr/local/lib/python3.13/unittest/mock.py:2328: StopAsyncIteration
----------------------------- Captured stdout call -----------------------------
DEBUG: Team Infrastructure Team (167e0dbc-59cd-46de-b9f4-58147d99474c) - Members: 1 - IDs: [UUID('3637fa19-9051-4be3-ace6-d86d0ce9734a')]
___________ TestGetTeamPerformance.test_team_performance_empty_team ____________

self = <tests.unit.api.test_analytics.TestGetTeamPerformance object at 0xffff98190550>
mock_db = <AsyncMock id='281473232256512'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_team_performance_empty_team(self, mock_db, manager_user):
        """Should handle teams with no members."""
        team = Team(id=uuid.uuid4(), name="Empty Team")
    
        mock_teams = MagicMock()
        mock_scalars = MagicMock()
        mock_scalars.all.return_value = [team]
        mock_teams.scalars.return_value = mock_scalars
    
        # Empty members
        mock_members = MagicMock()
        mock_members.all.return_value = []
    
        mock_db.execute.side_effect = [mock_teams, mock_members]
    
        result = await get_team_performance(mock_db, manager_user, days=30)
    
>       assert len(result.teams) == 1
                   ^^^^^^^^^^^^

tests/unit/api/test_analytics.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = TeamPerformanceResponse(items=[TeamPerformance(team_id=UUID('f22a7df0-89b6-43dc-8757-8105f997d93a'), team_name='Empty ..._resolved=0, open_tickets=0, resolution_rate=0.0, average_resolution_hours=None, average_rating=None, member_count=0)])
item = 'teams'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra and item in pydantic_extra:
                return pydantic_extra[item]
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'TeamPerformanceResponse' object has no attribute 'teams'. Did you mean: 'items'?

.venv/lib/python3.13/site-packages/pydantic/main.py:1026: AttributeError
----------------------------- Captured stdout call -----------------------------
DEBUG: Team Empty Team (f22a7df0-89b6-43dc-8757-8105f997d93a) - Members: 0 - IDs: []
________________ TestGetCurrentUserInfo.test_returns_user_info _________________

self = <tests.unit.api.test_auth.TestGetCurrentUserInfo object at 0xffff98191e50>

    async def test_returns_user_info(self):
        """Should return current user's information."""
        now = datetime.now(timezone.utc)
        user = User(
            id=uuid.uuid4(),
            phone_number="+905551234567",
            name="Test User",
            email="test@example.com",
            role=UserRole.CITIZEN,
            is_verified=True,
            is_active=True,
            created_at=now,
            updated_at=now,
        )
    
>       result = await get_current_user_info(user)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: get_current_user_info() missing 1 required positional argument: 'db'

tests/unit/api/test_auth.py:549: TypeError
_____________ TestCreateEscalation.test_create_escalation_success ______________

self = <tests.unit.api.test_escalations.TestCreateEscalation object at 0xffff98000690>
mock_db = <AsyncMock id='281473184573024'>
support_user = <User +905551234567 (SUPPORT)>

    async def test_create_escalation_success(self, mock_db, support_user):
        """Should create escalation for ticket assigned to user's team."""
        ticket_id = uuid.uuid4()
        ticket = Ticket(
            id=ticket_id,
            title="Test Ticket",
            status=TicketStatus.IN_PROGRESS,
            team_id=support_user.team_id,
            reporter_id=uuid.uuid4(),
        )
    
        escalation_data = EscalationCreate(
            ticket_id=ticket_id,
            reason="Need manager review for complex issue",
        )
    
        # Mock ticket lookup
        mock_ticket_result = MagicMock()
        mock_ticket_result.scalar_one_or_none.return_value = ticket
    
        # Mock existing escalations check
        mock_escalation_result = MagicMock()
        mock_scalars = MagicMock()
        mock_scalars.all.return_value = []
        mock_escalation_result.scalars.return_value = mock_scalars
    
        mock_db.execute.side_effect = [mock_ticket_result, mock_escalation_result]
    
>       result = await create_escalation(escalation_data, support_user, mock_db)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/api/test_escalations.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/v1/escalations.py:130: in create_escalation
    response = _build_escalation_response(escalation)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

escalation = <MagicMock name='mock.scalar_one()' id='281473231174832'>

    def _build_escalation_response(escalation: EscalationRequest) -> EscalationResponse:
        """Build an escalation response."""
>       return EscalationResponse(
            id=escalation.id,
            ticket_id=escalation.ticket_id,
            ticket_title=escalation.ticket.title if escalation.ticket else None,
            requester_id=escalation.requester_id,
            requester_name=escalation.requester.name if escalation.requester else None,
            reviewer_id=escalation.reviewer_id,
            reviewer_name=escalation.reviewer.name if escalation.reviewer else None,
            reason=escalation.reason,
            status=escalation.status,
            review_comment=escalation.review_comment,
            created_at=escalation.created_at,
            reviewed_at=escalation.reviewed_at,
        )
E       pydantic_core._pydantic_core.ValidationError: 10 validation errors for EscalationResponse
E       id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473231172480'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       ticket_id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473231159712'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       ticket_title
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...e' id='281473232256512'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       requester_id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473232255840'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       requester_name
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...e' id='281473231160048'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       reviewer_id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473184576048'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       reviewer_name
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...e' id='281473184572688'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       reason
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...n' id='281473184575376'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       status
E         Input should be 'PENDING', 'APPROVED' or 'REJECTED' [type=enum, input_value=<MagicMock name='mock.sca...s' id='281473184571680'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/enum
E       review_comment
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...t' id='281473184575040'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type

app/api/v1/escalations.py:32: ValidationError
__________ TestCreateEscalation.test_create_escalation_pending_exists __________

self = <tests.unit.api.test_escalations.TestCreateEscalation object at 0xffff981d30b0>
mock_db = <AsyncMock id='281473184571344'>
support_user = <User +905551234567 (SUPPORT)>

    async def test_create_escalation_pending_exists(self, mock_db, support_user):
        """Should raise EscalationAlreadyExistsException when pending exists."""
        ticket = Ticket(
            id=uuid.uuid4(),
            title="Test Ticket",
            status=TicketStatus.IN_PROGRESS,
            team_id=support_user.team_id,
            reporter_id=uuid.uuid4(),
        )
    
        pending_escalation = EscalationRequest(
            id=uuid.uuid4(),
            ticket_id=ticket.id,
            status=EscalationStatus.PENDING,
        )
    
        escalation_data = EscalationCreate(
            ticket_id=ticket.id,
            reason="Test reason",
        )
    
        mock_ticket_result = MagicMock()
        mock_ticket_result.scalar_one_or_none.return_value = ticket
    
        mock_escalation_result = MagicMock()
        mock_scalars = MagicMock()
        mock_scalars.all.return_value = [pending_escalation]
        mock_escalation_result.scalars.return_value = mock_scalars
    
        mock_db.execute.side_effect = [mock_ticket_result, mock_escalation_result]
    
        with pytest.raises(EscalationAlreadyExistsException):
>           await create_escalation(escalation_data, support_user, mock_db)

tests/unit/api/test_escalations.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/v1/escalations.py:130: in create_escalation
    response = _build_escalation_response(escalation)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

escalation = <MagicMock name='mock.scalar_one()' id='281473088295264'>

    def _build_escalation_response(escalation: EscalationRequest) -> EscalationResponse:
        """Build an escalation response."""
>       return EscalationResponse(
            id=escalation.id,
            ticket_id=escalation.ticket_id,
            ticket_title=escalation.ticket.title if escalation.ticket else None,
            requester_id=escalation.requester_id,
            requester_name=escalation.requester.name if escalation.requester else None,
            reviewer_id=escalation.reviewer_id,
            reviewer_name=escalation.reviewer.name if escalation.reviewer else None,
            reason=escalation.reason,
            status=escalation.status,
            review_comment=escalation.review_comment,
            created_at=escalation.created_at,
            reviewed_at=escalation.reviewed_at,
        )
E       pydantic_core._pydantic_core.ValidationError: 10 validation errors for EscalationResponse
E       id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473088299632'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       ticket_id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473184573360'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       ticket_title
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...e' id='281473088299968'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       requester_id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473088398608'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       requester_name
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...e' id='281473088403312'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       reviewer_id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=<MagicMock name='mock.sca...d' id='281473088403984'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type
E       reviewer_name
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...e' id='281473088395920'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       reason
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...n' id='281473088401632'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type
E       status
E         Input should be 'PENDING', 'APPROVED' or 'REJECTED' [type=enum, input_value=<MagicMock name='mock.sca...s' id='281473088400624'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/enum
E       review_comment
E         Input should be a valid string [type=string_type, input_value=<MagicMock name='mock.sca...t' id='281473088402640'>, input_type=MagicMock]
E           For further information visit https://errors.pydantic.dev/2.12/v/string_type

app/api/v1/escalations.py:32: ValidationError
_____________ TestListEscalations.test_list_escalations_as_manager _____________

self = <tests.unit.api.test_escalations.TestListEscalations object at 0xffff98000910>
mock_db = <AsyncMock id='281473088305008'>
manager_user = <User +905559999999 (MANAGER)>

    async def test_list_escalations_as_manager(self, mock_db, manager_user):
        """Manager should see all escalations."""
        escalation = EscalationRequest(
            id=uuid.uuid4(),
            ticket_id=uuid.uuid4(),
            requester_id=uuid.uuid4(),
            status=EscalationStatus.PENDING,
            reason="Test",
        )
    
        # Mock count
        mock_count = MagicMock()
        mock_count.scalar.return_value = 1
    
        # Mock escalations
        mock_result = MagicMock()
        mock_scalars = MagicMock()
        mock_scalars.all.return_value = [escalation]
        mock_result.scalars.return_value = mock_scalars
    
        mock_db.execute.side_effect = [mock_count, mock_result]
    
        result = await list_escalations(
            manager_user,
            mock_db,
            status_filter=None,
            ticket_id=None,
            page=1,
            page_size=10,
        )
    
        assert result.total == 1
>       assert len(result.items) == 1
E       assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = EscalationListResponse(items=[], total=1).items

tests/unit/api/test_escalations.py:247: AssertionError
________________ TestGetEscalation.test_get_escalation_success _________________

self = <tests.unit.api.test_escalations.TestGetEscalation object at 0xffff98000550>
mock_db = <AsyncMock id='281473088393232'>
support_user = <User +905551234567 (SUPPORT)>

    async def test_get_escalation_success(self, mock_db, support_user):
        """Should return escalation by ID."""
        escalation_id = uuid.uuid4()
        escalation = EscalationRequest(
            id=escalation_id,
            ticket_id=uuid.uuid4(),
            requester_id=support_user.id,
            status=EscalationStatus.PENDING,
            reason="Test reason",
        )
    
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = escalation
        mock_db.execute.return_value = mock_result
    
>       result = await get_escalation(escalation_id, support_user, mock_db)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/api/test_escalations.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/v1/escalations.py:226: in get_escalation
    return _build_escalation_response(escalation)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

escalation = <EscalationRequest 56a2369a-1f8c-450c-854e-500942d03d84 (PENDING)>

    def _build_escalation_response(escalation: EscalationRequest) -> EscalationResponse:
        """Build an escalation response."""
>       return EscalationResponse(
            id=escalation.id,
            ticket_id=escalation.ticket_id,
            ticket_title=escalation.ticket.title if escalation.ticket else None,
            requester_id=escalation.requester_id,
            requester_name=escalation.requester.name if escalation.requester else None,
            reviewer_id=escalation.reviewer_id,
            reviewer_name=escalation.reviewer.name if escalation.reviewer else None,
            reason=escalation.reason,
            status=escalation.status,
            review_comment=escalation.review_comment,
            created_at=escalation.created_at,
            reviewed_at=escalation.reviewed_at,
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for EscalationResponse
E       created_at
E         Input should be a valid datetime [type=datetime_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/datetime_type

app/api/v1/escalations.py:32: ValidationError
____________ TestApproveEscalation.test_approve_escalation_success _____________

self = <tests.unit.api.test_escalations.TestApproveEscalation object at 0xffff98000b90>
mock_db = <AsyncMock id='281473178976336'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_approve_escalation_success(self, mock_db, manager_user):
        """Should approve pending escalation."""
        escalation_id = uuid.uuid4()
        ticket = Ticket(
            id=uuid.uuid4(),
            title="Test Ticket",
            status=TicketStatus.ESCALATED,
        )
        escalation = EscalationRequest(
            id=escalation_id,
            ticket_id=ticket.id,
            requester_id=uuid.uuid4(),
            status=EscalationStatus.PENDING,
            reason="Need approval",
        )
        escalation.ticket = ticket
    
        review_data = EscalationReview(comment="Approved - proceed with fix")
    
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = escalation
        mock_db.execute.return_value = mock_result
    
>       result = await approve_escalation(
            escalation_id, review_data, manager_user, mock_db
        )

tests/unit/api/test_escalations.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/v1/escalations.py:280: in approve_escalation
    return _build_escalation_response(escalation)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

escalation = <EscalationRequest 3f806c5c-5008-4f70-9925-32702659d07c (APPROVED)>

    def _build_escalation_response(escalation: EscalationRequest) -> EscalationResponse:
        """Build an escalation response."""
>       return EscalationResponse(
            id=escalation.id,
            ticket_id=escalation.ticket_id,
            ticket_title=escalation.ticket.title if escalation.ticket else None,
            requester_id=escalation.requester_id,
            requester_name=escalation.requester.name if escalation.requester else None,
            reviewer_id=escalation.reviewer_id,
            reviewer_name=escalation.reviewer.name if escalation.reviewer else None,
            reason=escalation.reason,
            status=escalation.status,
            review_comment=escalation.review_comment,
            created_at=escalation.created_at,
            reviewed_at=escalation.reviewed_at,
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for EscalationResponse
E       created_at
E         Input should be a valid datetime [type=datetime_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/datetime_type

app/api/v1/escalations.py:32: ValidationError
_____________ TestRejectEscalation.test_reject_escalation_success ______________

self = <tests.unit.api.test_escalations.TestRejectEscalation object at 0xffff98000e10>
mock_db = <AsyncMock id='281473088292240'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_reject_escalation_success(self, mock_db, manager_user):
        """Should reject pending escalation."""
        escalation_id = uuid.uuid4()
        ticket = Ticket(
            id=uuid.uuid4(),
            title="Test Ticket",
            status=TicketStatus.ESCALATED,
        )
        escalation = EscalationRequest(
            id=escalation_id,
            ticket_id=ticket.id,
            requester_id=uuid.uuid4(),
            status=EscalationStatus.PENDING,
            reason="Need approval",
        )
        escalation.ticket = ticket
    
        review_data = EscalationReview(comment="Rejected - handle normally")
    
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = escalation
        mock_db.execute.return_value = mock_result
    
>       result = await reject_escalation(
            escalation_id, review_data, manager_user, mock_db
        )

tests/unit/api/test_escalations.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/v1/escalations.py:334: in reject_escalation
    return _build_escalation_response(escalation)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

escalation = <EscalationRequest 168643bf-0dfc-4ccf-9c97-2ecf28f1686e (REJECTED)>

    def _build_escalation_response(escalation: EscalationRequest) -> EscalationResponse:
        """Build an escalation response."""
>       return EscalationResponse(
            id=escalation.id,
            ticket_id=escalation.ticket_id,
            ticket_title=escalation.ticket.title if escalation.ticket else None,
            requester_id=escalation.requester_id,
            requester_name=escalation.requester.name if escalation.requester else None,
            reviewer_id=escalation.reviewer_id,
            reviewer_name=escalation.reviewer.name if escalation.reviewer else None,
            reason=escalation.reason,
            status=escalation.status,
            review_comment=escalation.review_comment,
            created_at=escalation.created_at,
            reviewed_at=escalation.reviewed_at,
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for EscalationResponse
E       created_at
E         Input should be a valid datetime [type=datetime_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/datetime_type

app/api/v1/escalations.py:32: ValidationError
____________ TestListNotifications.test_list_notifications_success _____________

self = <tests.unit.api.test_notifications.TestListNotifications object at 0xffff98001590>
mock_db = <AsyncMock id='281473178990112'>
citizen_user = <User +905551234567 (CITIZEN)>

    async def test_list_notifications_success(self, mock_db, citizen_user):
        """Should return paginated notifications."""
        now = datetime.now(timezone.utc)
        notification = Notification(
            id=uuid.uuid4(),
            user_id=citizen_user.id,
            notification_type=NotificationType.TICKET_STATUS_CHANGED,
            title="Status Updated",
            message="Your ticket status changed",
            is_read=False,
            created_at=now,
        )
    
        # Mock count
        mock_count_result = MagicMock()
        mock_count_result.scalar.return_value = 1
    
        # Mock notifications
        mock_notifications_result = MagicMock()
        mock_unique = MagicMock()
        mock_scalars = MagicMock()
        mock_scalars.all.return_value = [notification]
        mock_unique.scalars.return_value = mock_scalars
        mock_notifications_result.unique.return_value = mock_unique
    
        mock_db.execute.side_effect = [mock_count_result, mock_notifications_result]
    
>       result = await list_notifications(
            citizen_user, mock_db, unread_only=False, page=1, page_size=20
        )

tests/unit/api/test_notifications.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

current_user = <User +905551234567 (CITIZEN)>
db = <AsyncMock id='281473178990112'>, unread_only = False, page = 1
page_size = 20

    @router.get(
        "",
        response_model=NotificationListResponse,
        status_code=status.HTTP_200_OK,
    )
    async def list_notifications(
        current_user: CurrentUser,
        db: DatabaseSession,
        unread_only: bool = Query(default=False),
        page: int = Query(default=1, ge=1),
        page_size: int = Query(default=20, ge=1, le=100),
    ) -> NotificationListResponse:
        """List notifications for the current user."""
        query = select(Notification).where(Notification.user_id == current_user.id)
    
        if unread_only:
            query = query.where(Notification.is_read == False)  # noqa: E712
    
        # Get total count
        count_query = select(func.count()).select_from(query.subquery())
        total = (await db.execute(count_query)).scalar() or 0
    
        # Get paginated results
        query = (
            query.options(selectinload(Notification.ticket))
            .order_by(Notification.created_at.desc())
            .offset((page - 1) * page_size)
            .limit(page_size)
        )
    
        result = await db.execute(query)
        notifications = result.unique().scalars().all()
    
        return NotificationListResponse(
>           items=[NotificationResponse.model_validate(n) for n in notifications],
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            total=total,
            page=page,
            page_size=page_size,
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for NotificationResponse
E       updated_at
E         Input should be a valid datetime [type=datetime_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/datetime_type

app/api/v1/notifications.py:54: ValidationError
___________________ TestMarkAsRead.test_mark_as_read_success ___________________

self = <tests.unit.api.test_notifications.TestMarkAsRead object at 0xffff98001bd0>
mock_db = <AsyncMock id='281473172020528'>
citizen_user = <User +905551234567 (CITIZEN)>

    async def test_mark_as_read_success(self, mock_db, citizen_user):
        """Should mark a notification as read."""
        notification_id = uuid.uuid4()
        now = datetime.now(timezone.utc)
        notification = Notification(
            id=notification_id,
            user_id=citizen_user.id,
            notification_type=NotificationType.TICKET_STATUS_CHANGED,
            title="Status Updated",
            message="Your ticket status changed",
            is_read=False,
            created_at=now,
        )
    
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = notification
        mock_db.execute.return_value = mock_result
    
>       await mark_as_read(notification_id, citizen_user, mock_db)

tests/unit/api/test_notifications.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

notification_id = UUID('6d8597e4-92c4-4e08-a885-5a1aea1005af')
current_user = <User +905551234567 (CITIZEN)>
db = <AsyncMock id='281473172020528'>

    @router.patch(
        "/{notification_id}/read",
        response_model=NotificationResponse,
        status_code=status.HTTP_200_OK,
    )
    async def mark_as_read(
        notification_id: UUID,
        current_user: CurrentUser,
        db: DatabaseSession,
    ) -> NotificationResponse:
        """Mark a notification as read."""
        query = select(Notification).where(
            Notification.id == notification_id,
            Notification.user_id == current_user.id,
        )
        result = await db.execute(query)
        notification = result.scalar_one_or_none()
    
        if not notification:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Notification not found"
            )
    
        notification.is_read = True
        notification.read_at = datetime.now(timezone.utc)
        await db.commit()
        await db.refresh(notification)
    
>       return NotificationResponse.model_validate(notification)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for NotificationResponse
E       updated_at
E         Input should be a valid datetime [type=datetime_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/datetime_type

app/api/v1/notifications.py:107: ValidationError
____________________ TestListTeams.test_list_teams_success _____________________

self = <tests.unit.api.test_teams.TestListTeams object at 0xffff98002350>
mock_db = <AsyncMock id='281473172023552'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_list_teams_success(self, mock_db, manager_user):
        """Should return list of teams with member counts."""
        team1 = make_team(name="Team 1")
        team2 = make_team(name="Team 2")
    
        # Mock teams query - list_teams returns list of (Team, member_count) tuples
        mock_result = MagicMock()
        mock_result.all.return_value = [(team1, 3), (team2, 5)]
        mock_db.execute.return_value = mock_result
    
>       result = await list_teams(mock_db, manager_user)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/api/test_teams.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

db = <AsyncMock id='281473172023552'>, _ = <User +905551234567 (MANAGER)>
page = Query(1), page_size = Query(20)

    @router.get("", response_model=TeamListResponse)
    async def list_teams(
        db: DatabaseSession,
        _: ManagerUser,
        page: int = Query(1, ge=1),
        page_size: int = Query(20, ge=1, le=100),
    ) -> TeamListResponse:
        """List teams with member count (only active members), paginated."""
>       offset = (page - 1) * page_size
                  ^^^^^^^^
E       TypeError: unsupported operand type(s) for -: 'Query' and 'int'

app/api/v1/teams.py:96: TypeError
_____________________ TestListTeams.test_list_teams_empty ______________________

self = <tests.unit.api.test_teams.TestListTeams object at 0xffff980020d0>
mock_db = <AsyncMock id='281473178990784'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_list_teams_empty(self, mock_db, manager_user):
        """Should return empty list when no teams exist."""
        mock_result = MagicMock()
        mock_result.all.return_value = []
        mock_db.execute.return_value = mock_result
    
>       result = await list_teams(mock_db, manager_user)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/api/test_teams.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

db = <AsyncMock id='281473178990784'>, _ = <User +905551234567 (MANAGER)>
page = Query(1), page_size = Query(20)

    @router.get("", response_model=TeamListResponse)
    async def list_teams(
        db: DatabaseSession,
        _: ManagerUser,
        page: int = Query(1, ge=1),
        page_size: int = Query(20, ge=1, le=100),
    ) -> TeamListResponse:
        """List teams with member count (only active members), paginated."""
>       offset = (page - 1) * page_size
                  ^^^^^^^^
E       TypeError: unsupported operand type(s) for -: 'Query' and 'int'

app/api/v1/teams.py:96: TypeError
___________________ TestCreateTeam.test_create_team_success ____________________

self = <tests.unit.api.test_teams.TestCreateTeam object at 0xffff98002c10>
mock_db = <AsyncMock id='281473088395584'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_create_team_success(self, mock_db, manager_user):
        """Should create a new team."""
        team_data = TeamCreate(name="New Team", description="Team description")
    
        # Mock: no existing team with same name
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db.execute.return_value = mock_result
    
>       result = await create_team(team_data, mock_db, manager_user)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/api/test_teams.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

team_data = TeamCreate(name='New Team', description='Team description', category_ids=[], district_ids=[])
db = <AsyncMock id='281473088395584'>, _ = <User +905551234567 (MANAGER)>

    @router.post("", response_model=TeamResponse, status_code=status.HTTP_201_CREATED)
    async def create_team(
        team_data: TeamCreate,
        db: DatabaseSession,
        _: ManagerUser,
    ) -> TeamResponse:
        """Create a new team with categories and districts."""
        import logging
        logger = logging.getLogger(__name__)
        logger.info(f"Creating team: {team_data.name}")
        logger.info(f"  Categories: {team_data.category_ids}")
        logger.info(f"  Districts: {team_data.district_ids}")
    
        existing = await db.execute(select(Team).where(Team.name == team_data.name))
        if existing.scalar_one_or_none():
            raise ConflictException(detail="Team with this name already exists")
    
        team = Team(
            name=team_data.name,
            description=team_data.description,
        )
        db.add(team)
        await db.flush()  # Get team.id before creating associations
    
        # Create TeamCategory associations
        for category_id in team_data.category_ids:
            team_category = TeamCategory(
                team_id=team.id,
                category_id=category_id,
            )
            db.add(team_category)
            logger.info(f"  Added category {category_id} to team")
    
        # Create TeamDistrict associations
        for district_id in team_data.district_ids:
            team_district = TeamDistrict(
                team_id=team.id,
                district_id=district_id,
            )
            db.add(team_district)
            logger.info(f"  Added district {district_id} to team")
    
        await db.commit()
        await db.refresh(team)
        logger.info(f"Team {team.name} created successfully with {len(team_data.category_ids)} categories and {len(team_data.district_ids)} districts")
>       return TeamResponse.model_validate(team)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 3 validation errors for TeamResponse
E       created_at
E         Input should be a valid datetime [type=datetime_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/datetime_type
E       updated_at
E         Input should be a valid datetime [type=datetime_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/datetime_type
E       id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/uuid_type

app/api/v1/teams.py:233: ValidationError
----------------------------- Captured stderr call -----------------------------
INFO:app.api.v1.teams:Creating team: New Team
INFO:app.api.v1.teams:  Categories: []
INFO:app.api.v1.teams:  Districts: []
INFO:app.api.v1.teams:Team New Team created successfully with 0 categories and 0 districts
------------------------------ Captured log call -------------------------------
INFO     app.api.v1.teams:teams.py:197 Creating team: New Team
INFO     app.api.v1.teams:teams.py:198   Categories: []
INFO     app.api.v1.teams:teams.py:199   Districts: []
INFO     app.api.v1.teams:teams.py:232 Team New Team created successfully with 0 categories and 0 districts
___________________ TestDeleteTeam.test_delete_team_success ____________________

self = <tests.unit.api.test_teams.TestDeleteTeam object at 0xffff98002ad0>
mock_db = <AsyncMock id='281473178984736'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_delete_team_success(self, mock_db, manager_user):
        """Should delete team and nullify members' team_id."""
        team_id = uuid.uuid4()
        team = make_team(id=team_id, name="Team to Delete")
    
        mock_db.get.return_value = team
    
>       result = await delete_team(team_id, mock_db, manager_user)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/api/test_teams.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

team_id = UUID('2be4d40d-2400-4612-800a-506de4af5d74')
db = <AsyncMock id='281473178984736'>, _ = <User +905551234567 (MANAGER)>

    @router.delete("/{team_id}", status_code=status.HTTP_204_NO_CONTENT)
    async def delete_team(
        team_id: uuid.UUID,
        db: DatabaseSession,
        _: ManagerUser,
    ) -> None:
        """Delete a team.
    
        Members will have team_id set to NULL.
        Assigned tickets will be automatically reassigned to another suitable team.
        If no suitable team is found, tickets are assigned to the Istanbul General Team.
        """
        import logging
        from app.models.ticket import Ticket
        from app.services.team_assignment_service import TeamAssignmentService
    
        logger = logging.getLogger(__name__)
    
        team = await db.get(Team, team_id)
        if not team:
            raise NotFoundException(detail="Team not found")
    
        # Prevent deletion of fallback team
        FALLBACK_TEAM_NAME = "Istanbul General Team"
        if team.name == FALLBACK_TEAM_NAME:
            raise ConflictException(detail=f"{FALLBACK_TEAM_NAME} cannot be deleted as it serves as a fallback for unassigned tickets")
    
        logger.info(f"Deleting team: {team.name} ({team_id})")
    
        # Reassign tickets to other teams
        tickets_query = select(Ticket).options(
            selectinload(Ticket.category),
            selectinload(Ticket.location),
        ).where(
            Ticket.team_id == team_id,
            Ticket.deleted_at.is_(None),
        )
        result = await db.execute(tickets_query)
>       tickets = result.scalars().all()
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'all'

app/api/v1/teams.py:300: AttributeError
----------------------------- Captured stderr call -----------------------------
INFO:app.api.v1.teams:Deleting team: Team to Delete (2be4d40d-2400-4612-800a-506de4af5d74)
------------------------------ Captured log call -------------------------------
INFO     app.api.v1.teams:teams.py:289 Deleting team: Team to Delete (2be4d40d-2400-4612-800a-506de4af5d74)
__________________ TestAddTeamMember.test_add_member_success ___________________

self = <tests.unit.api.test_teams.TestAddTeamMember object at 0xffff98003110>
mock_db = <AsyncMock id='281473088396256'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_add_member_success(self, mock_db, manager_user):
        """Should add user to team."""
        team_id = uuid.uuid4()
        user_id = uuid.uuid4()
    
        team = make_team(id=team_id, name="Test Team")
        user = make_user(
            id=user_id, phone_number="+905551111111", team_id=None, deleted_at=None
        )
    
        # Mock db.get calls: first for team, second for user
        mock_db.get.side_effect = [team, user]
    
        # Mock execute for _get_team_with_members helper
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = team
        mock_db.execute.return_value = mock_result
    
        await add_team_member(team_id, user_id, mock_db, manager_user)
    
>       assert user.team_id == team_id
E       AssertionError: assert None == UUID('5a4b8614-918d-49fa-bf8a-897e8f7e4bde')
E        +  where None = <User +905551111111 (CITIZEN)>.team_id

tests/unit/api/test_teams.py:348: AssertionError
_______________ TestAddTeamMember.test_add_member_user_not_found _______________

self = <tests.unit.api.test_teams.TestAddTeamMember object at 0xffff9802c2b0>
mock_db = <AsyncMock id='281473172019184'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_add_member_user_not_found(self, mock_db, manager_user):
        """Should raise NotFoundException for non-existent user."""
        team_id = uuid.uuid4()
        team = make_team(id=team_id, name="Test Team")
    
        # First call returns team, second returns None (user not found)
        mock_db.get.side_effect = [team, None]
    
        with pytest.raises(NotFoundException):
>           await add_team_member(team_id, uuid.uuid4(), mock_db, manager_user)

tests/unit/api/test_teams.py:367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

team_id = UUID('6d1e3f5d-27ba-4f74-a9e1-966bf7cf7a50')
user_id = UUID('5976a4b0-4fc0-4960-9cab-be165c1e70af')
db = <AsyncMock id='281473172019184'>, _ = <User +905551234567 (MANAGER)>

    @router.post("/{team_id}/members/{user_id}", response_model=TeamDetailResponse)
    async def add_team_member(
        team_id: uuid.UUID,
        user_id: uuid.UUID,
        db: DatabaseSession,
        _: ManagerUser,
    ) -> TeamDetailResponse:
        """Add (or move) a user into a team."""
        team = await db.get(Team, team_id)
        if not team:
            raise NotFoundException(detail="Team not found")
    
        user_check = await db.execute(
            select(User.id, User.team_id)
            .where(User.id == user_id, User.deleted_at.is_(None))
        )
        row = user_check.first()
        if not row:
            raise NotFoundException(detail="User not found")
    
>       current_team_id = row.team_id
                          ^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'team_id'

app/api/v1/teams.py:372: AttributeError
_______________ TestRemoveTeamMember.test_remove_member_success ________________

self = <tests.unit.api.test_teams.TestRemoveTeamMember object at 0xffff98003390>
mock_db = <AsyncMock id='281473088298288'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_remove_member_success(self, mock_db, manager_user):
        """Should remove user from team."""
        team_id = uuid.uuid4()
        user_id = uuid.uuid4()
    
        team = make_team(id=team_id, name="Test Team")
        user = make_user(
            id=user_id, phone_number="+905551111111", team_id=team_id, deleted_at=None
        )
    
        mock_db.get.side_effect = [team, user]
    
        result = await remove_team_member(team_id, user_id, mock_db, manager_user)
    
>       assert user.team_id is None
E       AssertionError: assert UUID('b0b07eea-84ad-4d65-b2cf-892765ba9afe') is None
E        +  where UUID('b0b07eea-84ad-4d65-b2cf-892765ba9afe') = <User +905551111111 (CITIZEN)>.team_id

tests/unit/api/test_teams.py:405: AssertionError
_____________ TestRemoveTeamMember.test_remove_member_not_in_team ______________

self = <tests.unit.api.test_teams.TestRemoveTeamMember object at 0xffff980034d0>
mock_db = <AsyncMock id='281473088300976'>
manager_user = <User +905551234567 (MANAGER)>

    async def test_remove_member_not_in_team(self, mock_db, manager_user):
        """Should raise NotFoundException when user not in team."""
        team_id = uuid.uuid4()
        user_id = uuid.uuid4()
    
        team = make_team(id=team_id, name="Test Team")
        user = make_user(
            id=user_id,
            phone_number="+905551111111",
            team_id=uuid.uuid4(),  # Different team
            deleted_at=None,
        )
    
        mock_db.get.side_effect = [team, user]
    
>       with pytest.raises(NotFoundException):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'app.core.exceptions.NotFoundException'>

tests/unit/api/test_teams.py:424: Failed
____________ TestTicketServiceUpdateStatus.test_new_to_in_progress _____________

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff980dd450>
mock_notify = <AsyncMock name='notify_ticket_status_changed' id='281473172025232'>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff94f2daf0>
mock_db = <AsyncMock id='281473172026912'>
support_user = <User +905559876543 (SUPPORT)>
new_ticket = <Ticket 4b1a828d-696a-4d57-bb52-9f45fead0731 (NEW)>

    @patch(
        "app.services.notification_service.notify_ticket_status_changed",
        new_callable=AsyncMock,
    )
    async def test_new_to_in_progress(
        self, mock_notify, ticket_service, mock_db, support_user, new_ticket
    ):
        """NEW -> IN_PROGRESS is a valid transition."""
>       result = await ticket_service.update_status(
            mock_db, new_ticket, TicketStatus.IN_PROGRESS, None, support_user
        )

tests/unit/services/test_ticket_service.py:374: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff94f2daf0>
db = <AsyncMock id='281473172026912'>
ticket = <Ticket 4b1a828d-696a-4d57-bb52-9f45fead0731 (NEW)>
new_status = <TicketStatus.IN_PROGRESS: 'IN_PROGRESS'>, comment = None
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
__________ TestTicketServiceUpdateStatus.test_in_progress_to_resolved __________

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff980dd590>
mock_notify = <AsyncMock name='notify_ticket_status_changed' id='281473088331728'>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff9757b1b0>
mock_db = <AsyncMock id='281473172024224'>
support_user = <User +905559876543 (SUPPORT)>
in_progress_ticket = <Ticket aa546ce5-c9fa-40ed-97ce-8c046c5a6eff (IN_PROGRESS)>

    @patch(
        "app.services.notification_service.notify_ticket_status_changed",
        new_callable=AsyncMock,
    )
    async def test_in_progress_to_resolved(
        self, mock_notify, ticket_service, mock_db, support_user, in_progress_ticket
    ):
        """IN_PROGRESS -> RESOLVED is a valid transition."""
>       result = await ticket_service.update_status(
            mock_db,
            in_progress_ticket,
            TicketStatus.RESOLVED,
            "Issue fixed",
            support_user,
        )

tests/unit/services/test_ticket_service.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff9757b1b0>
db = <AsyncMock id='281473172024224'>
ticket = <Ticket aa546ce5-c9fa-40ed-97ce-8c046c5a6eff (IN_PROGRESS)>
new_status = <TicketStatus.RESOLVED: 'RESOLVED'>, comment = 'Issue fixed'
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
____________ TestTicketServiceUpdateStatus.test_resolved_to_closed _____________

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff9802fe10>
mock_notify = <AsyncMock name='notify_ticket_status_changed' id='281473178990448'>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff95498a00>
mock_db = <AsyncMock id='281473088324336'>
support_user = <User +905559876543 (SUPPORT)>
resolved_ticket = <Ticket 5dc8e323-da28-422d-8ab6-c9f55075bd86 (RESOLVED)>

    @patch(
        "app.services.notification_service.notify_ticket_status_changed",
        new_callable=AsyncMock,
    )
    async def test_resolved_to_closed(
        self, mock_notify, ticket_service, mock_db, support_user, resolved_ticket
    ):
        """RESOLVED -> CLOSED is a valid transition."""
>       result = await ticket_service.update_status(
            mock_db, resolved_ticket, TicketStatus.CLOSED, None, support_user
        )

tests/unit/services/test_ticket_service.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff95498a00>
db = <AsyncMock id='281473088324336'>
ticket = <Ticket 5dc8e323-da28-422d-8ab6-c9f55075bd86 (RESOLVED)>
new_status = <TicketStatus.CLOSED: 'CLOSED'>, comment = None
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
______ TestTicketServiceUpdateStatus.test_resolved_to_in_progress_reopen _______

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff97f30050>
mock_notify = <AsyncMock name='notify_ticket_status_changed' id='281473088332400'>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff9c2fb7f0>
mock_db = <AsyncMock id='281473088331728'>
support_user = <User +905559876543 (SUPPORT)>
resolved_ticket = <Ticket cbe2d315-7577-4e2c-942c-9e8631713c26 (RESOLVED)>

    @patch(
        "app.services.notification_service.notify_ticket_status_changed",
        new_callable=AsyncMock,
    )
    async def test_resolved_to_in_progress_reopen(
        self, mock_notify, ticket_service, mock_db, support_user, resolved_ticket
    ):
        """RESOLVED -> IN_PROGRESS (reopen) is a valid transition."""
>       result = await ticket_service.update_status(
            mock_db,
            resolved_ticket,
            TicketStatus.IN_PROGRESS,
            "Reopening",
            support_user,
        )

tests/unit/services/test_ticket_service.py:423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff9c2fb7f0>
db = <AsyncMock id='281473088331728'>
ticket = <Ticket cbe2d315-7577-4e2c-942c-9e8631713c26 (RESOLVED)>
new_status = <TicketStatus.IN_PROGRESS: 'IN_PROGRESS'>, comment = 'Reopening'
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
_____________ TestTicketServiceUpdateStatus.test_new_to_escalated ______________

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff97f1d6d0>
mock_notify = <AsyncMock name='notify_ticket_status_changed' id='281473088332064'>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff9c2f8280>
mock_db = <AsyncMock id='281473088331056'>
support_user = <User +905559876543 (SUPPORT)>
new_ticket = <Ticket 7f74143c-6a3e-4ab8-a9a8-679efc5fa851 (NEW)>

    @patch(
        "app.services.notification_service.notify_ticket_status_changed",
        new_callable=AsyncMock,
    )
    async def test_new_to_escalated(
        self, mock_notify, ticket_service, mock_db, support_user, new_ticket
    ):
        """NEW -> ESCALATED is a valid transition."""
>       result = await ticket_service.update_status(
            mock_db,
            new_ticket,
            TicketStatus.ESCALATED,
            "Needs manager review",
            support_user,
        )

tests/unit/services/test_ticket_service.py:441: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff9c2f8280>
db = <AsyncMock id='281473088331056'>
ticket = <Ticket 7f74143c-6a3e-4ab8-a9a8-679efc5fa851 (NEW)>
new_status = <TicketStatus.ESCALATED: 'ESCALATED'>
comment = 'Needs manager review', current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
________ TestTicketServiceUpdateStatus.test_new_cannot_jump_to_resolved ________

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff981c7020>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff95180050>
mock_db = <AsyncMock id='281473088326688'>
support_user = <User +905559876543 (SUPPORT)>
new_ticket = <Ticket e854206d-f5be-43b9-b662-efbba9f43c19 (NEW)>

    async def test_new_cannot_jump_to_resolved(
        self, ticket_service, mock_db, support_user, new_ticket
    ):
        """NEW -> RESOLVED is NOT a valid transition."""
        with pytest.raises(InvalidStatusTransitionException):
>           await ticket_service.update_status(
                mock_db, new_ticket, TicketStatus.RESOLVED, None, support_user
            )

tests/unit/services/test_ticket_service.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff95180050>
db = <AsyncMock id='281473088326688'>
ticket = <Ticket e854206d-f5be-43b9-b662-efbba9f43c19 (NEW)>
new_status = <TicketStatus.RESOLVED: 'RESOLVED'>, comment = None
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
_________ TestTicketServiceUpdateStatus.test_new_cannot_jump_to_closed _________

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff981c7130>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff966b8a50>
mock_db = <AsyncMock id='281473088334752'>
support_user = <User +905559876543 (SUPPORT)>
new_ticket = <Ticket 7abb795b-c665-4037-b1e5-9461fbfa3ac0 (NEW)>

    async def test_new_cannot_jump_to_closed(
        self, ticket_service, mock_db, support_user, new_ticket
    ):
        """NEW -> CLOSED is NOT a valid transition."""
        with pytest.raises(InvalidStatusTransitionException):
>           await ticket_service.update_status(
                mock_db, new_ticket, TicketStatus.CLOSED, None, support_user
            )

tests/unit/services/test_ticket_service.py:466: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff966b8a50>
db = <AsyncMock id='281473088334752'>
ticket = <Ticket 7abb795b-c665-4037-b1e5-9461fbfa3ac0 (NEW)>
new_status = <TicketStatus.CLOSED: 'CLOSED'>, comment = None
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
___________ TestTicketServiceUpdateStatus.test_closed_cannot_change ____________

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff9800a450>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff9590cc30>
mock_db = <AsyncMock id='281473172025904'>
support_user = <User +905559876543 (SUPPORT)>
closed_ticket = <Ticket f7f63095-acfb-4181-984b-bf306d813659 (CLOSED)>

    async def test_closed_cannot_change(
        self, ticket_service, mock_db, support_user, closed_ticket
    ):
        """CLOSED tickets cannot transition to any other state."""
        with pytest.raises(InvalidStatusTransitionException):
>           await ticket_service.update_status(
                mock_db, closed_ticket, TicketStatus.IN_PROGRESS, None, support_user
            )

tests/unit/services/test_ticket_service.py:475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff9590cc30>
db = <AsyncMock id='281473172025904'>
ticket = <Ticket f7f63095-acfb-4181-984b-bf306d813659 (CLOSED)>
new_status = <TicketStatus.IN_PROGRESS: 'IN_PROGRESS'>, comment = None
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
_____ TestTicketServiceUpdateStatus.test_in_progress_cannot_jump_to_closed _____

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff9800aa50>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff95728f00>
mock_db = <AsyncMock id='281473172027248'>
support_user = <User +905559876543 (SUPPORT)>
in_progress_ticket = <Ticket 00655743-89c4-4aa9-b7a3-53d4228e2d62 (IN_PROGRESS)>

    async def test_in_progress_cannot_jump_to_closed(
        self, ticket_service, mock_db, support_user, in_progress_ticket
    ):
        """IN_PROGRESS -> CLOSED is NOT a valid transition (must resolve first)."""
        with pytest.raises(InvalidStatusTransitionException):
>           await ticket_service.update_status(
                mock_db, in_progress_ticket, TicketStatus.CLOSED, None, support_user
            )

tests/unit/services/test_ticket_service.py:484: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff95728f00>
db = <AsyncMock id='281473172027248'>
ticket = <Ticket 00655743-89c4-4aa9-b7a3-53d4228e2d62 (IN_PROGRESS)>
new_status = <TicketStatus.CLOSED: 'CLOSED'>, comment = None
current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
______ TestTicketServiceUpdateStatus.test_status_change_creates_log_entry ______

self = <tests.unit.services.test_ticket_service.TestTicketServiceUpdateStatus object at 0xffff980a8c80>
mock_notify = <AsyncMock name='notify_ticket_status_changed' id='281473088335424'>
ticket_service = <app.services.ticket_service.TicketService object at 0xffff95554550>
mock_db = <AsyncMock id='281473088334752'>
support_user = <User +905559876543 (SUPPORT)>
new_ticket = <Ticket 958479c6-88ab-402e-805b-049f61573ec1 (NEW)>

    @patch(
        "app.services.notification_service.notify_ticket_status_changed",
        new_callable=AsyncMock,
    )
    async def test_status_change_creates_log_entry(
        self, mock_notify, ticket_service, mock_db, support_user, new_ticket
    ):
        """Status change should create a StatusLog entry."""
>       await ticket_service.update_status(
            mock_db, new_ticket, TicketStatus.IN_PROGRESS, "Starting work", support_user
        )

tests/unit/services/test_ticket_service.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.ticket_service.TicketService object at 0xffff95554550>
db = <AsyncMock id='281473088334752'>
ticket = <Ticket 958479c6-88ab-402e-805b-049f61573ec1 (NEW)>
new_status = <TicketStatus.IN_PROGRESS: 'IN_PROGRESS'>
comment = 'Starting work', current_user = <User +905559876543 (SUPPORT)>

    async def update_status(
        self,
        db: AsyncSession,
        ticket: Ticket,
        new_status: TicketStatus,
        comment: str | None,
        current_user: User,
    ) -> Ticket:
        """Update ticket status with validation.
    
        Args:
            db: Database session.
            ticket: The ticket to update.
            new_status: The new status.
            comment: Optional comment for the status change.
            current_user: The user making the change.
    
        Returns:
            The updated ticket.
    
        Raises:
            InvalidStatusTransitionException: If the transition is not allowed.
            ForbiddenException: If support user tries to update ticket from another team.
        """
        # Support users can only update tickets from their own team
        if current_user.role == UserRole.SUPPORT:
            if ticket.team_id is None:
>               raise ForbiddenException(
                    detail="Cannot update status of unassigned tickets"
                )
E               app.core.exceptions.ForbiddenException: 403: Cannot update status of unassigned tickets

app/services/ticket_service.py:279: ForbiddenException
=========================== short test summary info ============================
FAILED tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_manager_can_access_team_performance
FAILED tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_team_performance_with_team
FAILED tests/integration/analytics/test_analytics.py::TestTeamPerformanceAnalytics::test_team_performance_with_assigned_tickets
FAILED tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_creates_status_log
FAILED tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_to_resolved_sets_resolved_at
FAILED tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_invalid_transition_fails
FAILED tests/integration/services/test_ticket_service_integration.py::TestUpdateStatus::test_update_status_notifies_reporter
FAILED tests/integration/test_permissions_integration.py::TestTicketManagementPermissions::test_support_can_manage_any_ticket
FAILED tests/integration/test_teams.py::TestListTeams::test_manager_lists_teams
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_to_in_progress
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_in_progress_to_resolved
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_resolved_to_closed
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_resolved_to_in_progress_reopen
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_to_escalated
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_in_progress_to_escalated
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_escalated_to_in_progress
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_cannot_jump_to_resolved
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_new_cannot_jump_to_closed
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_closed_cannot_change
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusTransitions::test_in_progress_cannot_jump_to_closed
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusPermissions::test_support_can_change_status
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusSideEffects::test_resolved_sets_resolved_at
FAILED tests/integration/tickets/test_ticket_status.py::TestStatusSideEffects::test_status_change_with_comment
FAILED tests/test_escalations.py::test_support_creates_escalation_for_own_team_ticket
FAILED tests/test_escalations.py::test_can_reescalate_after_rejection - Impor...
FAILED tests/unit/api/test_analytics.py::TestGetTeamPerformance::test_team_performance_with_teams
FAILED tests/unit/api/test_analytics.py::TestGetTeamPerformance::test_team_performance_empty_team/app/.venv/lib/python3.13/site-packages/_pytest/unraisableexception.py:33: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited
  gc.collect()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback

FAILED tests/unit/api/test_auth.py::TestGetCurrentUserInfo::test_returns_user_info
FAILED tests/unit/api/test_escalations.py::TestCreateEscalation::test_create_escalation_success
FAILED tests/unit/api/test_escalations.py::TestCreateEscalation::test_create_escalation_pending_exists
FAILED tests/unit/api/test_escalations.py::TestListEscalations::test_list_escalations_as_manager
FAILED tests/unit/api/test_escalations.py::TestGetEscalation::test_get_escalation_success
FAILED tests/unit/api/test_escalations.py::TestApproveEscalation::test_approve_escalation_success
FAILED tests/unit/api/test_escalations.py::TestRejectEscalation::test_reject_escalation_success
FAILED tests/unit/api/test_notifications.py::TestListNotifications::test_list_notifications_success
FAILED tests/unit/api/test_notifications.py::TestMarkAsRead::test_mark_as_read_success
FAILED tests/unit/api/test_teams.py::TestListTeams::test_list_teams_success
FAILED tests/unit/api/test_teams.py::TestListTeams::test_list_teams_empty - T...
FAILED tests/unit/api/test_teams.py::TestCreateTeam::test_create_team_success
FAILED tests/unit/api/test_teams.py::TestDeleteTeam::test_delete_team_success
FAILED tests/unit/api/test_teams.py::TestAddTeamMember::test_add_member_success
FAILED tests/unit/api/test_teams.py::TestAddTeamMember::test_add_member_user_not_found
FAILED tests/unit/api/test_teams.py::TestRemoveTeamMember::test_remove_member_success
FAILED tests/unit/api/test_teams.py::TestRemoveTeamMember::test_remove_member_not_in_team
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_to_in_progress
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_in_progress_to_resolved
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_resolved_to_closed
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_resolved_to_in_progress_reopen
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_to_escalated
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_cannot_jump_to_resolved
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_new_cannot_jump_to_closed
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_closed_cannot_change
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_in_progress_cannot_jump_to_closed
FAILED tests/unit/services/test_ticket_service.py::TestTicketServiceUpdateStatus::test_status_change_creates_log_entry
================== 54 failed, 599 passed in 79.48s (0:01:19) ===================
